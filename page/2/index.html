<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>Pross&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="RukiapR0ss">
  
  
  <meta property="og:type" content="website">
<meta property="og:title" content="Pross&#39;s Blog">
<meta property="og:url" content="https://pross.space/page/2/index.html">
<meta property="og:site_name" content="Pross&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="RukiapR0ss">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Pross&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">Pross&#39;s Blog</a></h1>
    <p><a href="/"></a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/about">About</a></li>
      
        <li><a href="/daysmatter">Daysmatter</a></li>
      
      
        <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content">




  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/blog/2019/.html">
  <time datetime="2019-12-10T01:56:59.000Z">
    2019-12-10
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/blog/2019/.html">SparkStreaming之解析mapWithState</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>最近经历挫折教育，今天闲得时间，整理状态管理之解析mapWithState。今天说道的mapWithState是从Spark1.6开始引入的一种新的状态管理机制，支持输出全量的状态和更新的状态，支持对状态超时的管理，和自主选择需要的输出。</p>
    
  </div>
  <footer class="end-sep">
    
      
        <div class="alignleft">
          <a href="/blog/2019/.html#more" class="more-link">Read More</a>
        </div>
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>



  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/blog/2019/.html">
  <time datetime="2019-10-19T10:52:15.000Z">
    2019-10-19
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/blog/2019/.html">SparkStreaming之解析updateStateByKey</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>说到Spark Streaming的状态管理，就会想到updateStateByKey，还有mapWithState。今天整理了一下，着重了解一下前者。</p>
<h4 id="状态管理的需求"><a href="#状态管理的需求" class="headerlink" title="状态管理的需求"></a>状态管理的需求</h4><p>举一个最简单的需求例子来解释状态（state）管理，现在有这样的一个需求：计算从数据流开始到目前为止单词出现的次数。是不是看起来很眼熟，这其实就是一个升级版的wordcount，只不过需要在每个batchInterval计算当前batch的单词计数，然后对各个批次的计数进行累加。每一个批次的累积的计数就是当前的一个状态值。我们需要把这个状态保存下来，和后面批次单词的计数结果来进行计算，这样我们就能不断的在历史的基础上进行次数的更新。</p>
<p>SparkStreaming提供了两种方法来解决这个问题：updateStateByKey和mapWithState。mapWithState是1.6版本新增的功能，官方说性能较updateStateByKey提升10倍。</p>
    
  </div>
  <footer class="end-sep">
    
      
        <div class="alignleft">
          <a href="/blog/2019/.html#more" class="more-link">Read More</a>
        </div>
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>



  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/blog/2019/.html">
  <time datetime="2019-09-09T15:10:18.000Z">
    2019-09-09
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/blog/2019/.html">Apache-Thrift-Thrift-Thrift</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>接着上篇文章说。</p>
<p>我们知道了Apache Thrift主要用于各个服务之间的RPC通信，并且支持跨语言；包括C++，Java，Python，PHP，Ruby，Go，Node.js等等，还有一些都没听说过的语言；而且从上篇文章的RPC例子中可以发现，Thrift是一个典型的CS（客户端/服务端）架构；加上跨语言的特性，我们可以推断一下：客户端和服务端是可以使用不同的语言开发的。</p>
<p>如果CS端可以使用不同的语言来开发，那么一定是有一种中间语言来关联客户端和服务端（相同语言也需要关联客户端和服务端）。其实这个答案都知道，那就是接口定义语言：IDL（Interface Description Language）；下面我们从IDL进行开场表演，进行一次Thrift RPC的完整演出。</p>
    
  </div>
  <footer class="end-sep">
    
      
        <div class="alignleft">
          <a href="/blog/2019/.html#more" class="more-link">Read More</a>
        </div>
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>



  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/blog/2019/.html">
  <time datetime="2019-08-16T16:13:44.000Z">
    2019-08-17
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/blog/2019/.html">远程过程调用</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>啊，原本是写一篇Apache Thrift in HiveServer，改写JDBC连接Hive相关应用的推文，因为HiveServer是使用Thrift提供服务创建网络RPC的多种语言客户端；单独拿出来说，使用Thrift也可以轻松构建RPC服务器，是轻量级的跨语言的远程服务调用框架。说到远程过程调用，感觉又要解释很多，所以就先上个前菜，说一说远程过程调用（RPC）；并加了一份佐料：关于JDBC连接Hive的实现。</p>
    
  </div>
  <footer class="end-sep">
    
      
        <div class="alignleft">
          <a href="/blog/2019/.html#more" class="more-link">Read More</a>
        </div>
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>



  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/blog/2019/.html">
  <time datetime="2019-05-29T09:04:41.000Z">
    2019-05-29
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/blog/2019/.html">理解Spark核心之RDD</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>Spark是围绕RDD的概念展开的，RDD是可以并行操作的容错元素集合。RDD全称是Resilient Distributed Datasets（弹性分布式数据集）</p>
<h4 id="理解RDD"><a href="#理解RDD" class="headerlink" title="理解RDD"></a>理解RDD</h4><p>如果你在Spark集群中加载了一个很大的文本数据，Spark就会将该文本抽象为一个RDD，这个RDD根据你定义的分区策略（比如HashKey）可以分为数个Partition，这样就可以对各个分区进行并行处理，从而提高效率。</p>
<p>RDD是一个容错的，并行的数据结构，可以让用户显示地将数据存储到磁盘和内存中，并能控制数据的分区。同时，RDD还提供了一组丰富的操作来操作这些数据。在这些操作中，比如Map、flatMap、filter等转换操作实现了monad模式（Monad是一种设计模式，表示将一个运算过程，通过函数拆解成互相连接的多个步骤；你只要提供下一步运算所需的函数，整个运算就会自动进行下去。），很好的切合了Scala的集合操作。另外，RDD还提供了比如join，groupBy，reduceByKey（action操作）等更为方便的操作，用来支持常见的数据运算。</p>
<p>RDD是一系列只读分区的集合，它只能从文件中读取并创建，或者从旧的RDD生成新的RDD。RDD的每一次变换操作都会生成新的RDD，而不是在原来的基础上进行修改，这种粗粒度的数据操作方式为RDD带来了容错和数据共享方面的优势，但是在面对大数据集中频繁的小操作的时候，显得效率比较低下。</p>
    
  </div>
  <footer class="end-sep">
    
      
        <div class="alignleft">
          <a href="/blog/2019/.html#more" class="more-link">Read More</a>
        </div>
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>



  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/blog/2019/.html">
  <time datetime="2019-03-15T12:56:12.000Z">
    2019-03-15
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/blog/2019/.html">Spark的运行模式</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>Spark是新一代基于内存的计算框架，是用于大规模数据处理的同意分析引擎。相比于Hadoop MapReduce计算框架，Spark将中间计算结果保留在内存中，速度提升10~100倍；同时采用弹性分布式数据集（RDD）实现迭代计算，更好的适用于数据挖掘、机器学习，极大的提升开发效率。</p>
<p>Spark的运行模式，它不仅支持单机模式，同时支持集群模式运行；这里具体的总结一下Spark的各种运行模式的区分。</p>
<h4 id="Local模式"><a href="#Local模式" class="headerlink" title="Local模式"></a>Local模式</h4><p>Local模式又称本地模式，通过Local模式运行非常简单，只需要把Spark的安装包解压后，改一些常用的配置即可使用，而不用启动Spark的Master、Worker进程（只有集群的Standalone模式运行时，才需要这两个角色），也不用启动Hadoop的服务，除非你需要用到HDFS。</p>
    
  </div>
  <footer class="end-sep">
    
      
        <div class="alignleft">
          <a href="/blog/2019/.html#more" class="more-link">Read More</a>
        </div>
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>



  

  <nav id="pagination">
  
    <a href="/" class="prev">Prev</a>
  
  
    <a href="/page/3/" class="next">Next</a>
  
  <div class="clearfix"></div>
</nav>

</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2021 <a href="/">RukiapR0ss</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>