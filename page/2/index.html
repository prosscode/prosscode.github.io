<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>Pross&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="RukiapR0ss">
  
  
  <meta property="og:type" content="website">
<meta property="og:title" content="Pross&#39;s Blog">
<meta property="og:url" content="https://pross.space/page/2/index.html">
<meta property="og:site_name" content="Pross&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="RukiapR0ss">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Pross&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">Pross&#39;s Blog</a></h1>
    <p><a href="/"></a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/daysmatter">Daysmatter</a></li>
      
      
        <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content">




  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/blog/2019/08/17/remote-procedure-call.html">
  <time datetime="2019-08-16T16:13:44.000Z">
    2019-08-17
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/blog/2019/08/17/remote-procedure-call.html">远程过程调用</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>啊，原本是写一篇Apache Thrift in HiveServer，改写JDBC连接Hive相关应用的推文，因为HiveServer是使用Thrift提供服务创建网络RPC的多种语言客户端；单独拿出来说，使用Thrift也可以轻松构建RPC服务器，是轻量级的跨语言的远程服务调用框架。说到远程过程调用，感觉又要解释很多，所以就先上个前菜，说一说远程过程调用（RPC）；并加了一份佐料：关于JDBC连接Hive的实现。</p>
    
  </div>
  <footer class="end-sep">
    
      
        <div class="alignleft">
          <a href="/blog/2019/08/17/remote-procedure-call.html#more" class="more-link">Read More</a>
        </div>
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>



  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/blog/2019/05/29/understand-the-rdd-at-core-of-spark.html">
  <time datetime="2019-05-29T09:04:41.000Z">
    2019-05-29
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/blog/2019/05/29/understand-the-rdd-at-core-of-spark.html">理解Spark核心之RDD</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>Spark是围绕RDD的概念展开的，RDD是可以并行操作的容错元素集合。RDD全称是Resilient Distributed Datasets（弹性分布式数据集）</p>
<h4 id="理解RDD"><a href="#理解RDD" class="headerlink" title="理解RDD"></a>理解RDD</h4><p>如果你在Spark集群中加载了一个很大的文本数据，Spark就会将该文本抽象为一个RDD，这个RDD根据你定义的分区策略（比如HashKey）可以分为数个Partition，这样就可以对各个分区进行并行处理，从而提高效率。</p>
<p>RDD是一个容错的，并行的数据结构，可以让用户显示地将数据存储到磁盘和内存中，并能控制数据的分区。同时，RDD还提供了一组丰富的操作来操作这些数据。在这些操作中，比如Map、flatMap、filter等转换操作实现了monad模式（Monad是一种设计模式，表示将一个运算过程，通过函数拆解成互相连接的多个步骤；你只要提供下一步运算所需的函数，整个运算就会自动进行下去。），很好的切合了Scala的集合操作。另外，RDD还提供了比如join，groupBy，reduceByKey（action操作）等更为方便的操作，用来支持常见的数据运算。</p>
<p>RDD是一系列只读分区的集合，它只能从文件中读取并创建，或者从旧的RDD生成新的RDD。RDD的每一次变换操作都会生成新的RDD，而不是在原来的基础上进行修改，这种粗粒度的数据操作方式为RDD带来了容错和数据共享方面的优势，但是在面对大数据集中频繁的小操作的时候，显得效率比较低下。</p>
    
  </div>
  <footer class="end-sep">
    
      
        <div class="alignleft">
          <a href="/blog/2019/05/29/understand-the-rdd-at-core-of-spark.html#more" class="more-link">Read More</a>
        </div>
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>



  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/blog/2019/03/15/spark-operating-mode.html">
  <time datetime="2019-03-15T12:56:12.000Z">
    2019-03-15
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/blog/2019/03/15/spark-operating-mode.html">Spark的运行模式</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>Spark是新一代基于内存的计算框架，是用于大规模数据处理的同意分析引擎。相比于Hadoop MapReduce计算框架，Spark将中间计算结果保留在内存中，速度提升10~100倍；同时采用弹性分布式数据集（RDD）实现迭代计算，更好的适用于数据挖掘、机器学习，极大的提升开发效率。</p>
<p>Spark的运行模式，它不仅支持单机模式，同时支持集群模式运行；这里具体的总结一下Spark的各种运行模式的区分。</p>
<h4 id="Local模式"><a href="#Local模式" class="headerlink" title="Local模式"></a>Local模式</h4><p>Local模式又称本地模式，通过Local模式运行非常简单，只需要把Spark的安装包解压后，改一些常用的配置即可使用，而不用启动Spark的Master、Worker进程（只有集群的Standalone模式运行时，才需要这两个角色），也不用启动Hadoop的服务，除非你需要用到HDFS。</p>
    
  </div>
  <footer class="end-sep">
    
      
        <div class="alignleft">
          <a href="/blog/2019/03/15/spark-operating-mode.html#more" class="more-link">Read More</a>
        </div>
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>



  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/blog/2019/02/02/use-swagger2-to-build-a-restful-api.html">
  <time datetime="2019-02-01T17:00:44.000Z">
    2019-02-02
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/blog/2019/02/02/use-swagger2-to-build-a-restful-api.html">使用Swagger2构建RESTful API</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>吐槽了一阵公司提供的记录接口文档工具后，抽个空档时间搭了个RESTful风格的API文档Demo，感觉还不错，在这里记录一下，技术栈使用Spring Boot+Swagger2。</p>
<p>Swagger可以很轻松的整合到Spring Boot中，在代码里根据swagger语法打些标签，生成可预览的Api文档，减少了很多时间写API接口文档上，让维护文档和修改代码整合一体了，并且可以与Spring MVC程序配合组织出强大RESTful API文档，也能提供了强大的页面测试功能来调试测试每个接口。</p>
    
  </div>
  <footer class="end-sep">
    
      
        <div class="alignleft">
          <a href="/blog/2019/02/02/use-swagger2-to-build-a-restful-api.html#more" class="more-link">Read More</a>
        </div>
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>



  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/blog/2019/01/13/hash-table.html">
  <time datetime="2019-01-13T14:55:23.000Z">
    2019-01-13
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/blog/2019/01/13/hash-table.html">散列表</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>关于算法系列，在前面已经整理过大O表示法和排序算法相关的文章，今天接着上次的话说一说散列表（Hash Table，也叫哈希表），顺便穿插和另外两种基本的数据结构，数组和链表比较；并在最后介绍良好的散列函数——SHA函数的使用。这三种基本数据结构，可简可繁，在写代码时候都是比较频繁使用的，那我们先从散列表开始入手。</p>
<p>散列表是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做<code>散列函数</code>，存放记录的数组称做<code>散列表</code>。散列表是最有用的基本数据结构之一，我们需要总结散列表：实现、冲突和散列函数。</p>
    
  </div>
  <footer class="end-sep">
    
      
        <div class="alignleft">
          <a href="/blog/2019/01/13/hash-table.html#more" class="more-link">Read More</a>
        </div>
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>



  
    <article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/blog/2019/01/01/introduction-and-realization-of-several-timing-scheduling.html">
  <time datetime="2019-01-01T04:01:53.000Z">
    2019-01-01
  </time>
</a>
    
    
  
    <h1 class="title"><a href="/blog/2019/01/01/introduction-and-realization-of-several-timing-scheduling.html">几种定时调度的介绍与实现</a></h1>
  

  </header>
  
  <div class="entry">
    
      <p>由需求产出的一篇文章，憋了很久。以下将会看到，使用Timer进行任务调度，用ScheduledExecutor和Calendar实现任务调度，Spring中的任务调度TaskScheduler，开源工具包Quartz的简单介绍。</p>
<h4 id="使用Timer任务调度"><a href="#使用Timer任务调度" class="headerlink" title="使用Timer任务调度"></a>使用Timer任务调度</h4><p>Timer是<code>java.util.Timer</code>提供的比较简单的调度工具，实现任务调度的核心是Timer和TimerTask。其中Timer负责在<code>schedule</code>方法中设定TimerTask任务，以及任务执行的起始时间<code>delay</code>和间隔执行的时间<code>period</code>；TimerTask负责创建需要调度的任务，开发者需要实现<code>run</code>方法，然后将其丢给Timer去执行即可。</p>
    
  </div>
  <footer class="end-sep">
    
      
        <div class="alignleft">
          <a href="/blog/2019/01/01/introduction-and-realization-of-several-timing-scheduling.html#more" class="more-link">Read More</a>
        </div>
      
      
    
    <div class="clearfix"></div>
  </footer>
</article>



  

  <nav id="pagination">
  
    <a href="/" class="prev">Prev</a>
  
  
    <a href="/page/3/" class="next">Next</a>
  
  <div class="clearfix"></div>
</nav>

</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2021 <a href="/">RukiapR0ss</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>