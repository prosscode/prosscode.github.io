<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PROSS</title>
  
  <subtitle>Great minds have purpose, others have only wishes.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://prosscode.github.io/"/>
  <updated>2018-03-17T05:37:03.395Z</updated>
  <id>https://prosscode.github.io/</id>
  
  <author>
    <name>彭爽</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HDFS核心设计</title>
    <link href="https://prosscode.github.io/2018/HDFS%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1/"/>
    <id>https://prosscode.github.io/2018/HDFS核心设计/</id>
    <published>2018-03-15T00:43:04.000Z</published>
    <updated>2018-03-17T05:37:03.395Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 17 2018 13:38:21 GMT+0800 (中国标准时间) --><ul><li>心跳机制</li><li>安全模式</li><li>副本存放策略</li><li>负载均衡</li></ul><a id="more"></a><h3 id="HDFS相关概念"><a href="#HDFS相关概念" class="headerlink" title="HDFS相关概念"></a>HDFS相关概念</h3><p>HDFS（Hadoop Distributed File System Hadoop）分布式文件系统，主要用来解决海量数据的存储问题</p><p>HDFS中的文件在物理上是分块（block）存储，块的大小可以通过配置参数（dfs.blocksize）来规定，默认在Hadoop2.x版本中是128MB。</p><p>HDFS文件的各个block的存储管理由DataNode节点承担，DataNode是HDFS集群从节点，每一个block都可以在多个DataNode上存储多个副本（副本数量可以通过参数设置dfs.replication，默认是3）。</p><p>HDFS是设计成适应一次写入，多次读出的场景，不支持文件的修改。</p><p>HDFS核心API：Configuration、FileSystem。</p><h3 id="HDFS架构解释"><a href="#HDFS架构解释" class="headerlink" title="HDFS架构解释"></a>HDFS架构解释</h3><p>在上一篇的<a href="https://prosscode.github.io/2018/Hadoop集群环境搭建/">Hadoop集群环境搭建</a>中对集群规划分为：NameNode、DataNode、SecondaryNameNode以及ResourceManager和NodeManager。我们只知道需要这样去规划一个基本的分布式集群，并不知其所以然，那么这里对HDFS部分名词阐释：</p><p>主节点Namenode：掌管文件系统目录树，管理文件系统的元数据（一个block元信息消耗大约150byte的内存），负责保持和分配文件副本的数量，并处理客户端读写的请求。客户端请求访问HDFS都是通过向NameNode申请来进行的。</p><p>从节点DataNode：存储整个集群的所有的数据块，处理真正的数据读写。通过心跳机制定期汇报给NameNode有关block的信息。</p><p>SecondaryNameNode：严格说并不是NameNode备份节点，而是NameNode的助手，主要给NameNode分担压力之用。</p><p>下图可以很好的帮助理解</p><p><img src="/2018/HDFS核心设计/1.jpg" alt=""></p><h3 id="HDFS核心设计"><a href="#HDFS核心设计" class="headerlink" title="HDFS核心设计"></a>HDFS核心设计</h3><p><strong>心跳机制（HearBeat）</strong></p><p>在上面架构解释中说到，DataNode通过心跳机制定期汇报给NameNode有关block的信息，那么HDFS的心跳机制是什么原理呢？</p><p>我们知道，Hadoop是Master（NameNode、ResourceManager）/Slave（DataNode、NodeManager）结构，Master启动的时候会启动一个IPC（Inter-Process Comunocation，进程通信）server服务，等待Slave的连接；而Slave启动时，会主动连接master的IPC server服务，并且是每隔3秒连接一次master，这个每隔一段时间去连接一次的机智，我们形象的称为<strong>心跳</strong>。</p><p>Slave通过心跳汇报自己的信息给Master，Master也通过心跳给Slave下达命令；NameNode通过心跳得知DataNode的状态，ResourceManager 通过心跳得知 NodeManager 的状态。如果Master长时间都没有收到slave的心跳，就认为slave挂掉了，那么NameNode感知到Data挂掉死亡的时长是怎么计算的呢？</p><p>原理是这样的：DataNode启动好了之后，会专门启动一个线程来负责给NameNode发送心跳数据包，如果整个DataNode没有任何问题，但是仅仅只是当前负责发送信息的数据包线程挂掉了，那么NameNode会发送命名向这个DataNode进行确认，如果第一次没有返回结果，仅且只会检查第二次。如果发送数据包线程没有问题，是DataNode出现了某些问题，就没有DataNode的汇报；HDFS的标准： 如果连续10次没有收到DataNode的汇报，那么NameNode就会认为该DataNode存在宕机的可能。</p><p>这里需要查看hdfs-site.xml配置文件中的两个相关设置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>heartbeat.recheck.interval<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>5000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.heartbeat.interval<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div></pre></td></tr></table></figure><p>那么计算公示就可以出来：<code>timeout=2*heartbeat.recheck.interval+10*dfs.heartbeat.interval</code></p><p>需要注意的是，<code>heartbeat.recheck.interval</code>时间单位是ms（毫秒，默认为5分钟），<code>dfs.heartbeat.interval</code>时间单位是s（秒，默认为3秒）。</p><p><strong>安全模式</strong></p><p>安全模式是HDFS的自我保护数据安全的措施，当NameNode发现集群中的block丢失率（默认为0.999f，可修改dfs.safemode.threshold.pct手动配置）达到一定比例时，NameNode就会进入安全模式，在安全模式下，客户端不能对HDFS上的任何数据进行操作，只能查看元数据信息。</p><p>安全模式常用操作命令：</p><p>强制NameNode退出安全模式：<code>hadoop dfsadmin -safemode leave</code></p><p>进入安全模式：<code>hadoop dfsadmin -safemode enter</code></p><p>查看安全模式状态：<code>hadoop dfsadmin -safemode get</code></p><p>等待安全模式结束：<code>hadoop dfsadmin -safemode wait</code></p><p><strong>副本存放策略</strong></p><p>数据分块存储和副本的存放是保证可靠性和高性能的关键</p><p>副本存放策略说明：HDFS默认的副本数是3，第一个Block副本放在客户端所在的Node里，如果客户端不在集群范围，则第一个Node随机选取（不会选择太满和太忙的Node），第二个副本放置到与第一个节点不同的机架中的其中一个Node，第三个副本在和第二个副本在同一个机架，随机放在不同的Node中。</p><p>下图Block1-3表示三个副本。</p><p><img src="/2018/HDFS核心设计/replication.png" alt=""></p><p>修改副本数：</p><p>修改集群文件hdfs-site.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div></pre></td></tr></table></figure><p>命令设置：命令+副本数+文件夹路径或某个文件路径</p><p><code>bin/hadoop fs -setrep -R 2 /</code></p><p><strong>负载均衡</strong></p><p>节点与节点之间磁盘利用率不平衡是HDFS集群非常容易出现的情况（集群内新增，删除节点，某个节点机器内一个盘存储达到饱和等）当HDFS负载不均衡时，需要对HDFS进行数据的负载均衡调整，数据均衡过程的核心是一个数据均衡算法。进行数据的负载均衡调整必须满足以下原则：</p><ul><li>数据平衡不能导致数据块减少，数据备份的丢失</li><li>管理员可以终止数据平衡进程</li><li>每次移动的数据量以及占用的网络资源必须是可控的</li><li>数据均衡过程中，不能影响NameNode的正常工作</li></ul><p>影响Balancer的几个参数：</p><p><code>- threshold</code>：默认设置是10，参数范围0-100，判断集群是否平衡的阀值，理论上设置的越小，整个集群越平衡</p><p><code>dfs.balance.bandwidthPerSec</code>：默认值是1048576（1M/S），Balancer运行时允许占用的带宽</p><p>用命令设置：</p><p><code>hadoop dfsadmin -setBalanacerBandwidth 10485760</code></p><p><code>sbin/start-balancer.sh -t(threshold) 10%</code></p><p>在hdfs-site.xml配置文件中设置bandwidthPerSec：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.balance.bandwidthPerSec<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>10485760<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>负载均衡时的带宽大小设置<span class="tag">&lt;/<span class="name">description</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Mar 17 2018 13:38:21 GMT+0800 (中国标准时间) --&gt;&lt;ul&gt;&lt;li&gt;心跳机制&lt;/li&gt;&lt;li&gt;安全模式&lt;/li&gt;&lt;li&gt;副本存放策略&lt;/li&gt;&lt;li&gt;负载均衡&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="BigData" scheme="https://prosscode.github.io/tags/BigData/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop集群环境搭建</title>
    <link href="https://prosscode.github.io/2018/Hadoop%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://prosscode.github.io/2018/Hadoop集群环境搭建/</id>
    <published>2018-03-03T09:33:25.000Z</published>
    <updated>2018-03-07T07:49:28.503Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 17 2018 13:38:21 GMT+0800 (中国标准时间) --><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ul><li><p>虚拟机（VMware Workstation）</p></li><li><p>Xshell5</p></li><li><p>Linux系统（CentOS-6.7-x86_64-bin-iso）</p></li><li><p>Hadoop编译后的安装包（hadoop-2.7.5-centos-6.7.tar.gz）</p></li><li><p>JDK（jdk-8u73-linux-x64.tar.gz）、</p><a id="more"></a></li></ul><h3 id="集群规划"><a href="#集群规划" class="headerlink" title="集群规划"></a>集群规划</h3><table><thead><tr><th></th><th>HDFS</th><th>YRAN</th></tr></thead><tbody><tr><td>Hadoop02</td><td>NameNode+DataNode</td><td>NodeManager</td></tr><tr><td>Hadoop03</td><td>DataNode+SecondaryNameNode</td><td>NodeManager</td></tr><tr><td>Hadoop04</td><td>DataNode</td><td>NodeManager</td></tr><tr><td>Hadoop05</td><td>DataNode</td><td>ResourceManager+NodeManager</td></tr></tbody></table><p>集群共四个节点，HDFS主节点为Hadoop02，YRAN主节点为Hadoop05</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><strong>集群搭建：Haddoop02、Hadoop03、Hadoop04、Hadoop05</strong></p><ul><li>各个节点必须固定IP地址，并互相配置集群所有的主机映射</li><li>安装JDK，配置SSH免密登录（相互持有对方的公钥，就算是自己也需要持有）</li><li>关闭防火墙，关闭防火墙自动开启（关系到web管理页面是否能访问成功）</li><li>除root用户外，统一增加用户名：hadoop</li><li>可以配置一个节点后，克隆其余三个节点</li></ul><p><strong>解压Hadoop安装包，这里指定路径：/home/hadoop/apps/hadoop-2.7.5</strong></p><ul><li><p>修改hadoop的环境变量：普通用户（~/etc/.bashrc），root用户（/etc/profile）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">export HADOOP_HOME=/home/hadoop/apps/hadoop-2.7.5</div><div class="line">  </div><div class="line">export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</div></pre></td></tr></table></figure></li></ul><p><strong>配置Hadoop配置文件（见下方详情）</strong></p><ul><li>先配置一个节点中的配置文件，然后通过scp分发到其余的节点</li><li>所有节点的Hadoop安装路径和配置文件必须一致</li></ul><p><strong>启动Hadoop集群</strong></p><ul><li>初始化</li><li>启动HDFS</li><li>启动YARN</li></ul><p><strong>检测验证是否成功</strong></p><ul><li>JPS命令查看各个节点进程</li><li>查看集群状态：<code>hdfs dfsadmin -report</code> 、<code>hadoop dfsadmin -report</code></li><li>HDFSweb管理页面：<a href="https://hadoop02:50070" target="_blank" rel="external">https://hadoop02:50070</a></li><li>YARNweb管理页面：<a href="https://hadoop05:8088" target="_blank" rel="external">https://hadoop05:8088</a></li></ul><h3 id="修改Hadoop配置文件"><a href="#修改Hadoop配置文件" class="headerlink" title="修改Hadoop配置文件"></a>修改Hadoop配置文件</h3><p>Hadoop配置文件需要修改六个，路径在：hadoop-2.7.5/etc/hadoop/</p><p><img src="/2018/Hadoop集群环境搭建/1.png" alt=""></p><p><strong>hadoop-env.sh</strong></p><ul><li><p>默认的JAVA_HOME变量，建议修改JAVA_HOME的路径为jdk的原始路径</p><p><img src="/2018/Hadoop集群环境搭建/2.png" alt=""></p></li></ul><p><strong>core-site.xml</strong></p><ul><li><p>添加hdfs配置路径，文件上传端口，临时文件存放的目录等</p><p><img src="/2018/Hadoop集群环境搭建/3.png" alt=""></p></li></ul><p><strong>hdfs-site.xml</strong></p><ul><li><p>namenode、datanode数据存储的目录，数据备份副本的个数，以及第二主节点</p><p><img src="/2018/Hadoop集群环境搭建/4.png" alt=""></p></li></ul><p><strong>mapred-site.xml</strong></p><ul><li><p>配置名mapreduce-yarn管理</p><p><img src="/2018/Hadoop集群环境搭建/5.png" alt=""></p></li></ul><p><strong>yarn-site.xml</strong></p><ul><li><p>yarn的主机名等</p><p><img src="/2018/Hadoop集群环境搭建/6.png" alt=""></p></li></ul><p><strong>slaves</strong></p><ul><li><p>集群的节点列表。slaves文件中配置的是DataNode的所在节点服务，方便Hadoop启动时去寻找当前集群的节点，从而命令对应的服务器启动对应的进程</p><p><img src="/2018/Hadoop集群环境搭建/7.png" alt=""></p></li></ul><h3 id="启动Hadoop集群"><a href="#启动Hadoop集群" class="headerlink" title="启动Hadoop集群"></a>启动Hadoop集群</h3><ul><li><p>初始化只能在主节点中进行：<code>（/home/hadoop/apps/hadoop-2.7.5/）bin/hadoop namenode -format</code></p></li><li><p>哪个节点启动HDFS均可：<code>（/home/hadoop/apps/hadoop-2.7.5/）sbin/start-dfs.sh</code></p></li><li><p>YARN启动必须在主节点：<code>（/home/hadoop/apps/hadoop-2.7.5/）sbin/start-yarn.sh</code></p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Mar 17 2018 13:38:21 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;前期准备&quot;&gt;&lt;a href=&quot;#前期准备&quot; class=&quot;headerlink&quot; title=&quot;前期准备&quot;&gt;&lt;/a&gt;前期准备&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;虚拟机（VMware Workstation）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Xshell5&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Linux系统（CentOS-6.7-x86_64-bin-iso）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Hadoop编译后的安装包（hadoop-2.7.5-centos-6.7.tar.gz）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;JDK（jdk-8u73-linux-x64.tar.gz）、&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="BigData" scheme="https://prosscode.github.io/tags/BigData/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop生态体系</title>
    <link href="https://prosscode.github.io/2018/Hadoop%E7%94%9F%E6%80%81%E4%BD%93%E7%B3%BB/"/>
    <id>https://prosscode.github.io/2018/Hadoop生态体系/</id>
    <published>2018-03-03T03:49:58.000Z</published>
    <updated>2018-03-04T06:08:45.080Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 17 2018 13:38:21 GMT+0800 (中国标准时间) --><h2 id="Hadoop体系架构图"><a href="#Hadoop体系架构图" class="headerlink" title="Hadoop体系架构图"></a>Hadoop体系架构图</h2><a id="more"></a><p><strong>hadoop1.0</strong></p><p><img src="/2018/Hadoop生态体系/1.png" alt=""></p><p><strong>hadoop2.0</strong></p><p><img src="/2018/Hadoop生态体系/2.png" alt=""></p><p><strong>演变过程</strong></p><p><img src="/2018/Hadoop生态体系/3.png" alt=""></p><p><strong>Hadoop生态系统部分组件导图</strong></p><p><img src="/2018/Hadoop生态体系/4.png" alt=""></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Mar 17 2018 13:38:21 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;Hadoop体系架构图&quot;&gt;&lt;a href=&quot;#Hadoop体系架构图&quot; class=&quot;headerlink&quot; title=&quot;Hadoop体系架构图&quot;&gt;&lt;/a&gt;Hadoop体系架构图&lt;/h2&gt;
    
    </summary>
    
    
      <category term="BigData" scheme="https://prosscode.github.io/tags/BigData/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode：Merge Two Sorted Lists(#21)</title>
    <link href="https://prosscode.github.io/2018/LeetCode-Merge-Two-Sorted-Lists-21/"/>
    <id>https://prosscode.github.io/2018/LeetCode-Merge-Two-Sorted-Lists-21/</id>
    <published>2018-01-21T12:38:05.000Z</published>
    <updated>2018-03-04T06:21:06.395Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 17 2018 13:38:21 GMT+0800 (中国标准时间) --><p>LeetCode编号：21</p><a id="more"></a><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">标题</th><th style="text-align:center">等级</th></tr></thead><tbody><tr><td style="text-align:center">21</td><td style="text-align:center">Merge Two Sorted Lists</td><td style="text-align:center">Easy</td></tr></tbody></table><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p><strong>Example</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</div><div class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</div></pre></td></tr></table></figure><p><strong>Code Format</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Definition for singly-linked list.</span></div><div class="line"><span class="comment"> * public class ListNode &#123;</span></div><div class="line"><span class="comment"> *     int val;</span></div><div class="line"><span class="comment"> *     ListNode next;</span></div><div class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></div><div class="line"><span class="comment"> * &#125;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Mar 17 2018 13:38:21 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;LeetCode编号：21&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://prosscode.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode：Vaild Parentheses(#20)</title>
    <link href="https://prosscode.github.io/2018/LeetCode-Vaild-Parentheses-20/"/>
    <id>https://prosscode.github.io/2018/LeetCode-Vaild-Parentheses-20/</id>
    <published>2018-01-16T02:16:51.000Z</published>
    <updated>2018-03-04T06:21:15.232Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 17 2018 13:38:21 GMT+0800 (中国标准时间) --><p>LeetCode编号：20</p><a id="more"></a><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">标题</th><th style="text-align:center">等级</th></tr></thead><tbody><tr><td style="text-align:center">20</td><td style="text-align:center">Vail Parentheses</td><td style="text-align:center">Easy</td></tr></tbody></table><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p><p>The brackets must close in the correct order, <code>&quot;( )&quot;</code> and <code>&quot;( )[ ]{ }&quot;</code> are all valid but <code>&quot;( ]&quot;</code> and <code>&quot;( [ ) ]&quot;</code> are not.</p><p><strong>Code Format</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">      </div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><strong>题目要求</strong></p><p>根据LeetCode给出的题目说明：给出一个字符串包含一对小括号、中括号、大括号。需要判断是否是按照正确的的顺序排列的。即需要括号需要成对的在一起。</p><p><strong>解题思路</strong></p><p>可以通过截取字符串后压入栈中，然后做连续索引下的值是否比较进行判断。也可以通过字符串转化为字符数组，利用栈类的特性做匹配，进而做出判断。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><strong>Solution one</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</div><div class="line">            <span class="keyword">int</span> q = <span class="string">"()&#123;&#125;[]"</span>.indexOf(s.substring(i, i + <span class="number">1</span>));</div><div class="line">            <span class="keyword">if</span>(q % <span class="number">2</span> == <span class="number">1</span>) &#123;</div><div class="line">                <span class="keyword">if</span>(p.isEmpty() || stack.pop() != q - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                stack.push(q);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> stack.isEmpty();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>Solution two</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</div><div class="line"><span class="keyword">if</span> (c == <span class="string">'('</span>)&#123;</div><div class="line">            stack.push(<span class="string">')'</span>);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'&#123;'</span>)&#123;</div><div class="line">            stack.push(<span class="string">'&#125;'</span>);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'['</span>)&#123;</div><div class="line">            stack.push(<span class="string">']'</span>);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ((stack.isEmpty() || stack.pop() != c))&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> stack.isEmpty();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Stack中的两个方法：</p><ul><li>pop()：移除堆栈顶部的对象，并作为此函数的值返回该对象</li><li>push(E item)：将一个项目推到这个堆栈的顶部</li><li>栈是Vector的一个子类，它实现了一个标准的后进先出的栈</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Mar 17 2018 13:38:21 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;LeetCode编号：20&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://prosscode.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode：Palindrome Number(#9)</title>
    <link href="https://prosscode.github.io/2018/LeetCode-Palindrome-Number-9/"/>
    <id>https://prosscode.github.io/2018/LeetCode-Palindrome-Number-9/</id>
    <published>2018-01-02T12:50:47.000Z</published>
    <updated>2018-03-04T06:21:45.808Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 17 2018 13:38:21 GMT+0800 (中国标准时间) --><p>LeetCode编号：9</p><a id="more"></a><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">标题</th><th style="text-align:center">等级</th></tr></thead><tbody><tr><td style="text-align:center">9</td><td style="text-align:center">Palindrome Number</td><td style="text-align:center">Easy</td></tr></tbody></table><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Determine whether an integer is a palindrome. Do this without extra space.</p><p><strong>Some hints:</strong></p><p>Could negative integers be palindromes? (ie, -1)</p><p>If you are thinking of converting the integer to string, note the restriction of using extra space.</p><p>You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case?</p><p>There is a more generic way of solving this problem.</p><p><strong>Code Format</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><strong>题目要求</strong></p><p>题目要求很简单，判断是否为回文数。</p><p>LeetCode给出了提示：需要判断当<code>x</code>是负数、超过int的范围、反转后超过int的范围这三种情况。</p><p><strong>解题思路</strong></p><p>依照上次反转数字一样，当<code>x</code>是负数和超过int范围时，我们返回<code>false</code>，那么怎么解决反转后超过int类型范围呢，这里考虑用<code>long</code>来接收<code>x</code>的值再进行判断，那么第一种解法就出来了。</p><p>继续思考，反转的方式有哪些？第一种，利用StringBuffer的reverse()反转。第二种，采用数学的方式直接取模赋值，注意当<code>x</code>的值是<code>10</code>的倍数时判断。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><strong>Solution one</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">       Long l=(<span class="keyword">long</span>) x;</div><div class="line">       <span class="keyword">if</span> (l&gt; Integer.MAX_VALUE || l&lt;<span class="number">0</span>) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">         <span class="keyword">int</span> rex=Math.abs(x);</div><div class="line">         String str = Integer.toString(rex);</div><div class="line">         StringBuffer strb = <span class="keyword">new</span> StringBuffer(str);</div><div class="line">         strb.reverse();</div><div class="line">         Long re = Long.valueOf(strb.toString());</div><div class="line">         <span class="keyword">if</span> (re == rex) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">         &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>Solution two</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (x&lt;<span class="number">0</span> || (x!=<span class="number">0</span> &amp;&amp; x%<span class="number">10</span>==<span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">       <span class="keyword">int</span> rev = <span class="number">0</span>;</div><div class="line">       <span class="keyword">while</span> (x&gt;rev)&#123;</div><div class="line">         rev = rev*<span class="number">10</span> + x%<span class="number">10</span>;</div><div class="line">         x = x/<span class="number">10</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> (x==rev || x==rev/<span class="number">10</span>);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>第一种方式执行的时间明显比第二种方式长</li><li>在第二种解决办法中<code>while</code>循环进行反转后赋值的方法，以及<code>while</code>条件的判断，极大且有效的降低了0(n)</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Mar 17 2018 13:38:21 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;LeetCode编号：9&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://prosscode.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode：Reverse Integer(#7)</title>
    <link href="https://prosscode.github.io/2017/LeetCode-Reverse-Integer-7/"/>
    <id>https://prosscode.github.io/2017/LeetCode-Reverse-Integer-7/</id>
    <published>2017-12-24T07:06:11.000Z</published>
    <updated>2018-03-04T06:15:17.621Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 17 2018 13:38:21 GMT+0800 (中国标准时间) --><p>LeetCode编号：7</p><a id="more"></a><table><thead><tr><th>编号</th><th>标题</th><th>等级</th></tr></thead><tbody><tr><td>7</td><td>Reverse Integer</td><td>Easy</td></tr></tbody></table><h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><p>Given a 32-bit signed integer, reverse digits of an integer.</p><p><strong>Example 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input： 123</div><div class="line">Output： 321</div></pre></td></tr></table></figure><p><strong>Example 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input：-123</div><div class="line">Output：-321</div></pre></td></tr></table></figure><p><strong>Example 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input：120</div><div class="line">Output：21</div></pre></td></tr></table></figure><p><strong>note</strong></p><p>Assume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p><p><strong>Code Format</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>数字的反转，需要考虑并处理负数、个位为0以及反转后数值超过int类型的赋值范围的问题。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> m;</div><div class="line"><span class="keyword">long</span> sum = <span class="number">0</span>;</div><div class="line"><span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</div><div class="line">m = x % <span class="number">10</span>;</div><div class="line">sum = sum * <span class="number">10</span> + m;</div><div class="line">x = x / <span class="number">10</span>;</div><div class="line">&#125;</div><div class="line">        <span class="keyword">if</span>(sum&gt;Integer.MAX_VALUE || sum&lt;Integer.MIN_VALUE)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)sum;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Mar 17 2018 13:38:21 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;LeetCode编号：7&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://prosscode.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode：Two Sum(#1)</title>
    <link href="https://prosscode.github.io/2017/LeetCode-Two-Sum-1/"/>
    <id>https://prosscode.github.io/2017/LeetCode-Two-Sum-1/</id>
    <published>2017-12-17T05:26:33.000Z</published>
    <updated>2018-03-04T06:27:19.977Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 17 2018 13:38:21 GMT+0800 (中国标准时间) --><p>LeetCode编号：1</p><a id="more"></a><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">标题</th><th style="text-align:center">等级</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">Two Sum</td><td style="text-align:center">Easy</td></tr></tbody></table><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the <em>same</em> element twice.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Given nums = [2, 7, 11, 15], target = 9,</div><div class="line"></div><div class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</div><div class="line">return [0, 1].</div></pre></td></tr></table></figure><p><strong>Code Format</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</div><div class="line">      </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><strong>题目要求</strong></p><p>给定int型的数组nums，int型的target，该函数要求返回一个int型的数组。返回的数组是nums数组中两个元素的下标索引组成，该两个元素相加的和等于target，且一个元素只能使用一次。</p><p><strong>解题思路</strong></p><p>数组nums和值target已经确定，我们需要从nums中找出两个元素出来，且这两个元素的值和target相等。由此可以想到遍历数组两次，取出的元素和target进行比较。但是数组内的元素只能使用一次，那么我们需要去重后取出符合的元素，组合成新的数组并返回。这样逻辑思路就可以出来了。</p><p>继续思考，遍历两遍数组是不是增大了时间复杂度。还有没有和数组相类似的特性，可以解决找出其元素对应其数组索引的问题呢。答案是有的：集合。我们定义一个数组存放最终的返回值，定义一个集合来寻找符合的元素的索引值，这样就避免了再一次的循环数组。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><strong>Solution one</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum1(<span class="keyword">int</span> nums,<span class="keyword">int</span> target)&#123;</div><div class="line">  <span class="keyword">int</span>[] twoNum=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;</div><div class="line">        <span class="comment">//索引值不相等且其对应的元素值的和和target值相等，即元素符合题目要求</span></div><div class="line">          <span class="keyword">if</span>(i!=j &amp;&amp; (num[i]+num[j])==target)&#123;</div><div class="line">            twoNum[<span class="number">0</span>]=i;</div><div class="line">            twoNum[<span class="number">1</span>]=j;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> twoNum;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>Solution two</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum2(<span class="keyword">int</span> nums,<span class="keyword">int</span> target)&#123;</div><div class="line">  <span class="comment">//数组返回值，集合取出值</span></div><div class="line">  <span class="keyword">int</span>[] result=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</div><div class="line">  Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</div><div class="line">    <span class="comment">//如果集合中存在某个元素+nums[i]=target ，进if循环</span></div><div class="line">      <span class="keyword">if</span>(map.containsKey(target-nums[i]))&#123;</div><div class="line">         result[<span class="number">1</span>]=i;</div><div class="line">         result[<span class="number">0</span>]=(<span class="keyword">int</span>)map.get(target-num[i])-<span class="number">1</span>;</div><div class="line">         <span class="keyword">return</span> result;</div><div class="line">       &#125;</div><div class="line">    <span class="comment">//把nums数组内元素传到集合内,对应键和值</span></div><div class="line">     map.put(num[i],i+<span class="number">1</span>);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>两种方式在时间复杂度上区别还是很大的，在Submit Solution后，集合方式的Runtime时间大大减少。这里用到了集合中的containsKey()方法，get()方法，put()方法。</p><p>get(Object key)：返回指定键映射到的值，如果此映射不包含键映射，则返回null。</p><p>containsKey(Object key)：如果此映射包含指定键的映射，则返回true。</p><p>put(K key , V value)：将指定的值与此映射中指定的键关联。即存储元素在集合中。</p><p>for循环遍历数组，初始化数组。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Mar 17 2018 13:38:21 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;LeetCode编号：1&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://prosscode.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Linux下创建和删除用户</title>
    <link href="https://prosscode.github.io/2017/Linux%E4%B8%8B%E5%88%9B%E5%BB%BA%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7/"/>
    <id>https://prosscode.github.io/2017/Linux下创建删除用户/</id>
    <published>2017-11-27T12:40:56.000Z</published>
    <updated>2018-03-04T06:23:31.827Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 17 2018 13:38:22 GMT+0800 (中国标准时间) --><blockquote><p>Linux_CentOS7环境</p><p>Linux内置终端</p><p>管理员Root权限</p></blockquote><a id="more"></a><h3 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h3><p>在学习Linux基本命令操作过程中，在终端使用<code>useradd</code>命令可用来建立用户账号，用<code>passwd</code>设定账号的密码，可用userdel删除账号。不考虑缓冲天数，群组，备注，登入目录等设置。具体步骤如下：</p><ul><li><code># useradd maxpross</code> - 创建一个名字为maxpross的用户</li><li><code># ls /home</code> - 查看home目录下是否创建</li></ul><ul><li><code># userdel maxpross</code> - 删除用户</li><li><code># useradd maxpross</code> - 查看是否能重新创建用户</li></ul><p>然而事实并不能如我们所想的那样。</p><p><img src="/2017/Linux下创建删除用户/01.png" alt=""></p><p>useradd警告： 此目录已经存在。</p><h3 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h3><p>既然useradd是添加用户，userdel是删除目录，那么为什么不能按照我们的操作的预想创建成功呢，哪里有不对的地方呢？既然是已经存在 此目录，那是不是问题出现在没有删除干净的原因呢，我们来查找一下涉及到<code>maxpross</code>名字的文件有哪些：</p><p><code># find / -name &#39;*maxpross*&#39;</code></p><p>结果如下：</p><p><img src="/2017/Linux下创建删除用户/02.png" alt=""></p><p>那我们终于找到问题所在了，在/home目录和/var/spool/mail邮件池中存在着maxpross有关文件，<code>userdel</code>删除只是删除用户帐号，而没有删除相关文件，那么下次继续创建时候就会就会涉及到相关文件，系统就会提示，文件已经存在。</p><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>既然问题找到了，我们就需要来解决问题。先前我们已经删除了用户账号，那我们就手动删除查找出来的路径下的有关文件后，再执行添加操作。</p><p><code># rm -rf /var/spool/mail/maxpross /home/maxpross</code></p><p><code># useradd maxpross</code></p><p><code># ls /home</code></p><p><img src="/2017/Linux下创建删除用户/03.png" alt=""></p><p>创建成功，圆满解决。</p><h3 id="拓展问题"><a href="#拓展问题" class="headerlink" title="拓展问题"></a>拓展问题</h3><p>通过查找资料，我们知道<code>userdel</code>有一个参数<code>-r</code>：删除用户登入目录以及目录中所有文件，这下就很好解决用户的创建和删除的问题了！</p><p><code># userdel -r maxpross</code></p><p><code># useradd maxpross</code></p><p><img src="/2017/Linux下创建删除用户/04.png" alt=""></p><p>大家发现更好的解决办法欢迎联系我一起交流！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Mar 17 2018 13:38:22 GMT+0800 (中国标准时间) --&gt;&lt;blockquote&gt;&lt;p&gt;Linux_CentOS7环境&lt;/p&gt;&lt;p&gt;Linux内置终端&lt;/p&gt;&lt;p&gt;管理员Root权限&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://prosscode.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate核心配置文件总结</title>
    <link href="https://prosscode.github.io/2017/Hibernate%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%80%BB%E7%BB%93/"/>
    <id>https://prosscode.github.io/2017/Hibernate核心配置文件总结/</id>
    <published>2017-10-16T13:14:38.000Z</published>
    <updated>2018-03-04T06:18:37.760Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 17 2018 13:38:21 GMT+0800 (中国标准时间) --><h2 id="Hibernate核心配置文件步骤"><a href="#Hibernate核心配置文件步骤" class="headerlink" title="Hibernate核心配置文件步骤"></a>Hibernate核心配置文件步骤</h2><ul><li><p>引入约束</p></li><li><p>连接数据库（重点）</p></li><li><p>Hibernate中其他配置</p></li><li><p>引入映射文件（必须）</p><a id="more"></a></li></ul><p>按照hibernate核心文件配置的顺序是以上的排序。我现在以步骤的重要的先后顺序来按点讲解，顺便也当自己复习和回顾。</p><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>现在主要使用三种数据库：<a href="#mysql">MySQL</a>，<a href="#oracle">Oracle</a>，<a href="#sqlserver">SQL Server</a>。</p><h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;hibernate-configuration&gt;</div><div class="line">&lt;session-factory&gt;</div><div class="line">&lt;!--</div><div class="line">加载驱动</div><div class="line">连接数据库</div><div class="line">数据库用户名</div><div class="line">数据库密码</div><div class="line">  --&gt;</div><div class="line">&lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt;</div><div class="line">&lt;property name=<span class="string">"hibernate.connection.url"</span>&gt;jdbc:mysql:<span class="comment">//localhost:3306/DataBaseName&lt;/property&gt;</span></div><div class="line">&lt;property name="hibernate.connection.username"&gt;mysqlusername&lt;/property&gt;</div><div class="line">&lt;property name="hibernate.connection.password"&gt;mysqlpassword&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;/session-factory&gt;</div><div class="line">&lt;/hibernate-configuration&gt;</div></pre></td></tr></table></figure><h4 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;hibernate-configuration&gt;</div><div class="line">&lt;session-factory&gt;</div><div class="line"></div><div class="line">&lt;property name="hibernate.connection.driver_class"&gt;oracle.jdbc.driver.OracleDriver&lt;/property&gt;</div><div class="line">&lt;property name=<span class="string">"hibernate.connection.url"</span>&gt;</div><div class="line">jdbc:oracle:thin:@localhost:1521:dataBaseName&lt;/property&gt;</div><div class="line">&lt;property name="hibernate.connection.username"&gt;username&lt;/property&gt;</div><div class="line">&lt;property name="hibernate.connection.password"&gt;password&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;/session-factory&gt;</div><div class="line">&lt;/hibernate-configuration&gt;</div></pre></td></tr></table></figure><h4 id="SQL-Server"><a href="#SQL-Server" class="headerlink" title="SQL Server"></a>SQL Server</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;hibernate-configuration&gt;</div><div class="line">&lt;session-factory&gt;</div><div class="line"></div><div class="line">&lt;property name=<span class="string">"hibernate.connection.driver_class"</span>&gt;</div><div class="line">com.microsoft.sqlserver.jdbc.SQLServerDriver</div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property name=<span class="string">"hibernate.connection.url"</span>&gt;jdbc:sqlserver:<span class="comment">//localhost:1433;databaseName="xx"</span></div><div class="line">&lt;/property&gt;</div><div class="line">&lt;property name="hibernate.connection.username"&gt;username&lt;/property&gt;</div><div class="line">&lt;property name="hibernate.connection.password"&gt;password&lt;/property&gt;</div><div class="line"></div><div class="line">&lt;/session-factory&gt;</div><div class="line">&lt;/hibernate-configuration&gt;</div></pre></td></tr></table></figure><blockquote><p>官方给出配置信息可查看hibernate-release\project\etc内的hibernate.properties文件</p></blockquote><h3 id="引入映射文件"><a href="#引入映射文件" class="headerlink" title="引入映射文件"></a>引入映射文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;mapping resource=<span class="string">"org/itcast/entity/User.hbm.xml"</span>/&gt;</div></pre></td></tr></table></figure><blockquote><p>org.itcast.entity：包名。User.hbm.xml：映射文件名。</p></blockquote><h3 id="引入约束"><a href="#引入约束" class="headerlink" title="引入约束"></a>引入约束</h3><p>在配置文件头引入dtd约束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE hibernate-configuration PUBLIC</div><div class="line"><span class="string">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span></div><div class="line"><span class="string">"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"</span>&gt;</div></pre></td></tr></table></figure><h3 id="Hibernate中其他配置"><a href="#Hibernate中其他配置" class="headerlink" title="Hibernate中其他配置"></a>Hibernate中其他配置</h3><ul><li>输出底层sql语句并格式化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt;</div><div class="line">&lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt;</div></pre></td></tr></table></figure><ul><li>hibernate创建表</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//update：如果已经有表则更新，如果没有则创建</span></div><div class="line">&lt;property name="hibernate.hbm2ddl.auto"&gt;update&lt;/property&gt;</div></pre></td></tr></table></figure><ul><li>配置数据库方言</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// SQL Server </span></div><div class="line">&lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.SQLServerDialect&lt;/property&gt;</div><div class="line"><span class="comment">//MySQL三种：MySQLDialect、MySQLInnoDBDialect、MySQLMyISAMDialect</span></div><div class="line">&lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;</div><div class="line"><span class="comment">//Oracle三种：Oracle8iDialect、Oracle9iDialect、Oracle10gDialect</span></div><div class="line">&lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.Oracle8iDialect&lt;/property&gt;</div></pre></td></tr></table></figure><blockquote><p>数据库方言：在数据库里面相同的功可能是需要不同的关键字才能实现。比如：实现分页，mysql关键字是limit，oracle是rownum。为了区别并执行你写的底层sql语句，需要配置数据库相应的方言</p></blockquote><hr><p>简单的介绍一下这三种数据库：</p><p><span id="mysql">MySQL，最初的核心思想主要是开源、简便、易用。经过几次改版之后蜕变成一个成熟的关系型数据库系统，由于MySQL的早期定位，其主要应用场景就是互联网开发。基本上，互联网的爆发成就了MySQL，LAMP架构风靡天下。</span></p><p><span id="oracle">Oracle，基于运算架构了一种新型的数据存储模型，基于这种模型Oracle成为了一个非常典型的关系数据库，其主要特点是结构严谨、高性能、高可用。由于诞生的早，使其在传统数据库应用中大杀四方，金融、通信、能源、运输、零售、制造等各个行业的大型公司基本都是用了Oracle。</span></p><p><span id="sqlserver">SQL Server，一般是指MS SQL Server，其最大的优势在于集成了MS公司各类产品及资源，提供了强大了可视化界面、高度集成的管理工具。MS SQL Server是MS公司在软件集成方案中的重要一环，也为WIN系统在企业级应用中的普及做出了很大贡献。</span></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Mar 17 2018 13:38:21 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;Hibernate核心配置文件步骤&quot;&gt;&lt;a href=&quot;#Hibernate核心配置文件步骤&quot; class=&quot;headerlink&quot; title=&quot;Hibernate核心配置文件步骤&quot;&gt;&lt;/a&gt;Hibernate核心配置文件步骤&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;引入约束&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;连接数据库（重点）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Hibernate中其他配置&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;引入映射文件（必须）&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://prosscode.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>看书清单(#20170928)</title>
    <link href="https://prosscode.github.io/2017/%E7%9C%8B%E4%B9%A6%E6%B8%85%E5%8D%95/"/>
    <id>https://prosscode.github.io/2017/看书清单/</id>
    <published>2017-09-28T03:38:34.000Z</published>
    <updated>2018-03-04T06:23:47.239Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 17 2018 13:38:22 GMT+0800 (中国标准时间) --><p>书籍是程序员进步的阶梯，希望自己能坚持阅读和学习。</p><a id="more"></a><p>最近正在看的书籍清单整理如下：</p><p><strong>编码：隐匿在计算机软硬件背后的语言 </strong>- Charles Petzold著 / 左飞、薛佟佟译</p><p>这本书是驹哥在群里推荐的的计算机工作原理的书籍，作者是Windows编程界的传奇人物Charles Petzold。目前正在拜读，用很浅显易懂语言和知识一步步引导出存储器，处理器和操作系统等计算机硬件。没有门槛的限制，我觉得无论是不是专科人士都可以了解一下计算机软硬件的前因后果。</p><p><strong>Java多线程编程实战指南（核心篇）</strong> -黄文海</p><p>上次去校招面试，觉得自己在多线程技术方面还不够熟练，想更深层次的了解Java的多线程的原理和方法也是有必要的，综合各方面评价于是前天入手这本。希望自己勤加练习会有所得。</p><p><strong>精进：如何成为一个很厉害的人</strong> - 采铜</p><p>大彰鱼推荐的阅读，和Java多线程一起在京东上购买。这本书是作者的经历以及对经历的思考，以下是这本书的前言总结：采铜选取了影响人生的七个关键切面 - 时间、选择、行动、学习、思维、才能和成功；设计出精进的路径，帮助人们找到解决问题的支点，用持续精确的努力，撬动最大的可能。</p><p><code>Great minds have purpose, others have only wishes.</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Mar 17 2018 13:38:22 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;书籍是程序员进步的阶梯，希望自己能坚持阅读和学习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活杂记" scheme="https://prosscode.github.io/tags/%E7%94%9F%E6%B4%BB%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>网易校招面试题(#1)</title>
    <link href="https://prosscode.github.io/2017/%E7%BD%91%E6%98%93%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E9%A2%98-1/"/>
    <id>https://prosscode.github.io/2017/网易校招面试题-1/</id>
    <published>2017-09-22T17:39:12.000Z</published>
    <updated>2018-03-04T06:22:16.246Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 17 2018 13:38:22 GMT+0800 (中国标准时间) --><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><p>小易准备去魔法王国采购魔法神器,购买魔法神器需要使用魔法币,但是小易现在一枚魔法币都没有,但是小易有两台魔法机器可以通过投入x(x可以为0)个魔法币产生更多的魔法币。</p><p>魔法机器1:如果投入x个魔法币,魔法机器会将其变为2x+1个魔法币</p><p>魔法机器2:如果投入x个魔法币,魔法机器会将其变为2x+2个魔法币</p><p>小易采购魔法神器总共需要n个魔法币,所以小易只能通过两台魔法机器产生恰好n个魔法币,小易需要你帮他设计一个投入方案使他最后恰好拥有n个魔法币。</p></blockquote><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>魔法机器1只能产生奇数，魔法机器2只能产生偶数。</p><p>从n不断按奇偶倒推回0就可以解决。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Scanner;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">        <span class="keyword">while</span> (in.hasNext()) &#123;</div><div class="line">            <span class="keyword">int</span> coinCount = in.nextInt();</div><div class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">            <span class="keyword">while</span> (coinCount &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (coinCount % <span class="number">2</span> == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">//偶数</span></div><div class="line">                    coinCount = (coinCount - <span class="number">2</span>) / <span class="number">2</span>;</div><div class="line">                    sb.append(<span class="string">"2"</span>);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">//奇数</span></div><div class="line">                    coinCount = (coinCount - <span class="number">1</span>) / <span class="number">2</span>;</div><div class="line">                    sb.append(<span class="string">"1"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            System.out.println(sb.reverse().toString());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Mar 17 2018 13:38:22 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;小易准备去魔法王国采购魔法神器,购买魔法神器需要使用魔法币,但是小易现在一枚魔法币都没有,但是小易有两台魔法机器可以通过投入x(x可以为0)个魔法币产生更多的魔法币。&lt;/p&gt;&lt;p&gt;魔法机器1:如果投入x个魔法币,魔法机器会将其变为2x+1个魔法币&lt;/p&gt;&lt;p&gt;魔法机器2:如果投入x个魔法币,魔法机器会将其变为2x+2个魔法币&lt;/p&gt;&lt;p&gt;小易采购魔法神器总共需要n个魔法币,所以小易只能通过两台魔法机器产生恰好n个魔法币,小易需要你帮他设计一个投入方案使他最后恰好拥有n个魔法币。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://prosscode.github.io/tags/Java/"/>
    
      <category term="Interview" scheme="https://prosscode.github.io/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode：Non-decreasing Array(#665)</title>
    <link href="https://prosscode.github.io/2017/LeetCode-Non-decreasing-Array-665/"/>
    <id>https://prosscode.github.io/2017/LeetCode-Non-decreasing-Array-665/</id>
    <published>2017-09-21T11:36:30.000Z</published>
    <updated>2018-03-04T06:17:38.896Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 17 2018 13:38:21 GMT+0800 (中国标准时间) --><p>LeetCode编号：665</p><a id="more"></a><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">标题</th><th style="text-align:center">等级</th></tr></thead><tbody><tr><td style="text-align:center">665</td><td style="text-align:center">Non-decreasing Array</td><td style="text-align:center">Easy</td></tr></tbody></table><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>给定一个包含n个整数的数组，通过修改最多1个元素来检查是否可以变为非递减。</p><p>我们这样定义一个数组是非递减的：如果array [i] &lt;= array [i + 1]对于每个i（1 &lt;= i &lt;n）成立。</p><p>Note：The <code>n</code> belongs to [1,10000].</p><p>举例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Input：[<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line">Output：True</div><div class="line">Explanation：You could modify the first</div><div class="line"><span class="number">4</span> to <span class="number">1</span> </div><div class="line">  to get a non-decreasing array.</div></pre></td></tr></table></figure><p>举例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Input：[<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</div><div class="line">Output：False</div><div class="line">Explannation：You can not get a non-decreasing array by modify at most one element.</div></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>要求是非递减数组，且最多修改一个元素。</p><p>我们比较[i]和[i+1]下标的元素大小，如果[i] &gt; [i+1]，不是递减数组，继续往下判断。如果i &gt; 0，且[i+1] &lt; [i-1]，则把[i+1]的值赋给[i]，这样交换一次就能得到这三个数是递减排列。</p><p>循环比较，若继续判断[i] &gt; [i+1]，则返回False，否则返回True。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPossibility</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = nums.length;</div><div class="line">      <span class="keyword">int</span> bool = <span class="number">0</span>; <span class="comment">// 判定Boolean值</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; n; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i + <span class="number">1</span>]) &#123;</div><div class="line">                count++;</div><div class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i + <span class="number">1</span>] &lt; nums[i - <span class="number">1</span>]) &#123;</div><div class="line">                    nums[i + <span class="number">1</span>] = nums[i];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> nums[i] = nums[i + <span class="number">1</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> bool &lt;= <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Mar 17 2018 13:38:21 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;LeetCode编号：665&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://prosscode.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode：Second Highest Salary(#176)</title>
    <link href="https://prosscode.github.io/2017/LeetCode-Second-Highest-Salary-176/"/>
    <id>https://prosscode.github.io/2017/LeetCode-Second-Highest-Salary-176/</id>
    <published>2017-09-18T08:36:52.000Z</published>
    <updated>2018-03-04T06:16:32.628Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 17 2018 13:38:21 GMT+0800 (中国标准时间) --><p>LeetCode编号：176</p><a id="more"></a><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">标题</th><th style="text-align:center">等级</th></tr></thead><tbody><tr><td style="text-align:center">176</td><td style="text-align:center">Second Highest Salary</td><td style="text-align:center">Easy</td></tr></tbody></table><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>编写SQL查询，从<code>Employee</code>表中获得第二高的工资。</p><table><thead><tr><th style="text-align:center">Id</th><th style="text-align:center">Salary</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">100</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">200</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">300</td></tr></tbody></table><p>例如，给定上述Employee表，查询应该返回200作为第二高的工资。 如果没有第二高的工资，则查询应返回null。</p><table><thead><tr><th style="text-align:center">SecondHighestSalary</th></tr></thead><tbody><tr><td style="text-align:center">200</td></tr></tbody></table><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>按照下降的顺序排列工资，然后利用limit子句获得第二高工资</p><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><h4 id="Limit"><a href="#Limit" class="headerlink" title="Limit"></a>Limit</h4><p>使用查询语句的时候，要返回前几条或者中间某几行数据，Limit子句可以被用于强制Select语句返回指定的记录数。</p><p>语法：<code>select * from table limit m,n</code>，为了兼容PostgreSQL，支持<code>limit * from table m offset n</code></p><p>实例：<code>select * from table limit 2,4</code>，即取出第3条至第6条数据。</p><h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h4><p>去重，返回唯一不同的值。</p><p>####desc</p><p>按降序排列。asc，按升序排列。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select </div><div class="line">(select distinct Salary from Employee </div><div class="line">order by Salary desc </div><div class="line">limit 1 offset 1) as SecondHighestSalary</div></pre></td></tr></table></figure><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>利用IFNULL函数解决返回null的问题</p><h3 id="要点-1"><a href="#要点-1" class="headerlink" title="要点 "></a><strong>要点</strong></h3><h4 id="ifnull函数"><a href="#ifnull函数" class="headerlink" title="ifnull函数"></a>ifnull函数</h4><p>语法 ：<code>ifnull(expr1,expr2)</code>，如果expr1不是null，ifnull()返回expr1，否则返回expr2。<code>ifnull(expr1,expr2,expr3)</code>，如果expr1是true，那么ifnull()返回expr2，否则它返回expr3。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select </div><div class="line">ifnull(select distic Salary from employee order by Salary desc </div><div class="line">limit 1 offser 1),null) as SecondHighestSalary</div></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Mar 17 2018 13:38:21 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;LeetCode编号：176&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://prosscode.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>命名法(#编程规范)</title>
    <link href="https://prosscode.github.io/2017/%E5%91%BD%E5%90%8D%E6%B3%95-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    <id>https://prosscode.github.io/2017/命名法-编程规范/</id>
    <published>2017-09-12T03:50:09.000Z</published>
    <updated>2018-03-04T06:22:00.902Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 17 2018 13:38:22 GMT+0800 (中国标准时间) --><blockquote><p>驼峰式命名法 &amp; 帕斯卡命名法</p><p>匈牙利命名法</p><p>下划线命名法</p></blockquote><a id="more"></a><h2 id="驼峰式命名法"><a href="#驼峰式命名法" class="headerlink" title="驼峰式命名法"></a><strong>驼峰式命名法</strong></h2><blockquote><p>驼峰式命名法(CamelCase)是电脑程式编写时的一套命名规则，当变量名或函数式名是由一个或多个单字连接在一起而构成的唯一识别字时采用驼峰式命名法，一般分为小驼峰命名法和大驼峰命名法。</p></blockquote><ul><li><strong>小驼峰法</strong></li></ul><p>变量一般用小驼峰法标识。小驼峰法的意思是：除第一个单词之外，其他单词首字母大写。</p><p>比如：<code>int myStudentCount</code> 变量myStudentCount第一个单词全部小写，后面的单词首字母大写。</p><ul><li><strong>大驼峰法（即帕斯卡命名法）</strong></li></ul><p>相比小驼峰法，大驼峰法把第一个单词的首字母大写，常用于类名，函数名，属性，命名空间。</p><p>比如：<code>public class DataBaseUser</code> 类名DataBaseUser首字母单词全部大写。</p><h2 id="匈牙利命名法"><a href="#匈牙利命名法" class="headerlink" title="匈牙利命名法"></a><strong>匈牙利命名法</strong></h2><blockquote><p>匈牙利命名法师一种编程时的命名规范。基本原则是：<strong>变量名 =属性+类型+对象描述</strong>，其中每一对象的名称都要求有明确含义，可以取对象名字全程或名字的一部分。</p></blockquote><p>匈牙利命名法关键是：标识符代码名字以一个或者多个小写字母开头作为前缀，前缀之后的是首字母大写的一个单词或多个单词组合，该单词要指明变量的用途。</p><table><thead><tr><th style="text-align:center">前缀</th><th style="text-align:center">数据类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td style="text-align:center">Array</td><td style="text-align:center">数组</td></tr><tr><td style="text-align:center">b</td><td style="text-align:center">BOOL(int)</td><td style="text-align:center">布尔(整数)</td></tr><tr><td style="text-align:center">by</td><td style="text-align:center">Unsigned Char(Byte)</td><td style="text-align:center">无符号字符(字节)</td></tr><tr><td style="text-align:center">c</td><td style="text-align:center">Char</td><td style="text-align:center">字符(字节)</td></tr><tr><td style="text-align:center">cb</td><td style="text-align:center">Count of bytes</td><td style="text-align:center">字节数</td></tr><tr><td style="text-align:center">cr</td><td style="text-align:center">Color reference value</td><td style="text-align:center">颜色(参考)值</td></tr><tr><td style="text-align:center">cx，cy</td><td style="text-align:center">Count of x,y (Short int)</td><td style="text-align:center">x,y的集合(短整数)</td></tr><tr><td style="text-align:center">dw</td><td style="text-align:center">DWORD (unsigned long)</td><td style="text-align:center">双字(无符号长整数)</td></tr><tr><td style="text-align:center">f</td><td style="text-align:center">Flags (usually multiple bit values)</td><td style="text-align:center">标志(一般是有多位的数值)</td></tr><tr><td style="text-align:center">fn</td><td style="text-align:center">Function</td><td style="text-align:center">函数</td></tr><tr><td style="text-align:center">g_</td><td style="text-align:center">global</td><td style="text-align:center">全局的</td></tr><tr><td style="text-align:center">i</td><td style="text-align:center">Integer</td><td style="text-align:center">整型</td></tr><tr><td style="text-align:center">l</td><td style="text-align:center">Long int</td><td style="text-align:center">长整数</td></tr><tr><td style="text-align:center">msg</td><td style="text-align:center">message</td><td style="text-align:center">消息</td></tr><tr><td style="text-align:center">n</td><td style="text-align:center">Short Int</td><td style="text-align:center">短整型</td></tr><tr><td style="text-align:center">p</td><td style="text-align:center">Pointer</td><td style="text-align:center">指针</td></tr><tr><td style="text-align:center">s</td><td style="text-align:center">string</td><td style="text-align:center">字符串型</td></tr><tr><td style="text-align:center">v</td><td style="text-align:center">void</td><td style="text-align:center">空</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><p>举例：</p><p><code>pfnEatApple</code> pfn是类型描述，表示指向函数的指针；EatApple是变量对象描述，所以它表示指向EatApple函数的函数指针变量。</p><p><code>g_cch</code> g_是属性描述表示全局变量，c和ch分别是计数类型和字符类型，所以它表示一个对字符进行计数的全局变量。</p><blockquote><p>注：匈牙利命名法在C语言是难以实施，在C++语言中是无法实施</p></blockquote><h2 id="下划线命名法"><a href="#下划线命名法" class="headerlink" title="下划线命名法"></a><strong>下划线命名法</strong></h2><p>下划线命名法比较好理解，相比较于驼峰命名法来说，函数名中的每一个逻辑断点处都需要一个下划线来标记。</p><p>举例：<code>int my_student_count</code> 在每个单字母之间用下划线来标记分隔。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Mar 17 2018 13:38:22 GMT+0800 (中国标准时间) --&gt;&lt;blockquote&gt;&lt;p&gt;驼峰式命名法 &amp;amp; 帕斯卡命名法&lt;/p&gt;&lt;p&gt;匈牙利命名法&lt;/p&gt;&lt;p&gt;下划线命名法&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程规范" scheme="https://prosscode.github.io/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+GitHub博客搭建</title>
    <link href="https://prosscode.github.io/2017/Hexo+GitHub%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>https://prosscode.github.io/2017/Hexo+GitHub博客搭建/</id>
    <published>2017-09-07T06:55:02.000Z</published>
    <updated>2018-03-04T06:23:09.366Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 17 2018 13:38:21 GMT+0800 (中国标准时间) --><blockquote><p>Hexo框架</p><p>GitHub 托管</p></blockquote><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a><strong>准备工作</strong></h2><ul><li>为什么你应该从现在开始写博客参见 - <a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/" target="_blank" rel="external">刘未鹏-思维改变生活</a></li><li>了解什么是Hexo - <a href="https://hexo.io/" target="_blank" rel="external">A fast, simple &amp; powerful blog framework</a></li><li>Node.js &amp; Git 安装包</li><li><a href="http://cmder.net/" target="_blank" rel="external">cmder</a>(个人建议需要，可以用cmd)</li><li><a href="https://github.com/" target="_blank" rel="external">GitHub账号和邮箱</a></li></ul><h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a><strong>主要步骤</strong></h2><h3 id="创建github项目"><a href="#创建github项目" class="headerlink" title="创建github项目"></a><strong>创建github项目</strong></h3><p>登录自己的<a href="https://github.com/" target="_blank" rel="external">github</a></p><p>然后右上角选择<a href="https://github.com/new" target="_blank" rel="external">Create a new respsitory</a></p><p>Repository name处填写yourname.github.io(yourname与你的注册名一致，这个就是你的博客域名)</p><p>然后Create repository完成</p><p><img src="/2017/Hexo+GitHub博客搭建/1.png" alt=""></p><blockquote><p>1、例如我的域名是<a href="https://prosscode.github.io/">https://prosscode.github.io/</a>,就填入prosscode.github.io<br>2、你可以自己选择项目为公开的(public)开始私密的(private)</p></blockquote><hr><h3 id="node-js和Git环境配置"><a href="#node-js和Git环境配置" class="headerlink" title="node.js和Git环境配置"></a><strong>node.js和Git环境配置</strong></h3><p>安装<a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a> 和 <a href="https://github.com/waylau/git-for-win" target="_blank" rel="external">Git从国内下载需要翻墙，这里提供Git国内镜像下载</a></p><p>安装完成后,在开始菜单里找“Git-Git Bash”,打开输入:<br><code>$ git config --global user.name &quot;your github username&quot;</code><br>​<br>回车再次输入:<br><code>$ git config --global user.email &quot;your github email&quot;</code><br>​<br><img src="/2017/Hexo+GitHub博客搭建/2.png" alt=""><br>​<br>查看Git配置信息:<br><code>$ git config --list</code><br>​<br><img src="/2017/Hexo+GitHub博客搭建/3.png" alt=""></p><blockquote><p>1、github username是你的github账号，github email是你的github邮箱</p></blockquote><hr><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a><strong>安装Hexo</strong></h3><p>环境搭建完成后就使用npm安装Hexo，打开cmder输入:<br><code>$ npm install -g hexo-cli</code><br>​<br><img src="/2017/Hexo+GitHub博客搭建/4.png" alt=""><br>​</p><blockquote><p>1、Hexo现在最新的版本是3.3.8<br>2、安装hexo等待的时间会很长，请耐心等待不要关闭安装窗口</p></blockquote><hr><h3 id="博客设置"><a href="#博客设置" class="headerlink" title="博客设置"></a><strong>博客设置</strong></h3><p>安装完hexo框架后，在电脑磁盘内新建文件夹，命名为HexoBlog，进入文件夹按住Shift键点击鼠标右键，选择cmder here<br>​<br><img src="/2017/Hexo+GitHub博客搭建/5.png" alt=""><br>​<br>没有配置cmder环境变量的点击“在此处打开命令窗口”<br>​<br>输入: <code>λ hexo init blog</code><br>​<br>成功后提示：<br><code>INFO Start blogging with Hexo!</code><br>​<br>接下来输入:<br><code>λ hexo generate</code><br><code>λ hexo server</code></p><p>成功提示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">INFO  Start processing</div><div class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</div></pre></td></tr></table></figure><p></p><p>访问<a href="http://localhost:4000/" target="_blank" rel="external">localhost:4000</a>就可以看到网站的初始模样<br>​<br><img src="/2017/Hexo+GitHub博客搭建/6.png" alt=""><br>​<br>重新打开cmder输入：<br><code>λ ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot;</code></p><p>一路Enter，得到信息：<br><code>Your public key has been saved in /c/Users/user/.ssh/id_rsa.pub.</code><br>​<br>然后找到该文件打开(sublime text)，复制里面所有内容，然后进入<a href="https://github.com/settings/keys" target="_blank" rel="external">Github.settinhs/key</a>，New SSH key—Title：blog—key：输入你刚复制的—Add SSH key<br>​</p><blockquote><p>1、<code>hexo init name</code>命令会在HexoBlog文件夹下创建一个名为name的文件夹,并初始化hexo设置,并在source目录下自带一篇hello world文章<br>2、<code>hexo generate</code>命令是生成静态文件，可简写为：<code>hexo g</code><br>3、<code>hexo server</code>命令是启动本地服务，可简写为：<code>hexo s</code><br>4、访问<a href="http://localhost:4000/" target="_blank" rel="external">localhost:4000</a>必须要先执行<code>hexo s</code></p></blockquote><hr><h3 id="配置博客"><a href="#配置博客" class="headerlink" title="配置博客"></a><strong>配置博客</strong></h3><p>在blog目录下，用sublime打开_config.yml文件，配合我的博客信息和注释修改自己的博客信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"># Hexo Configuration</div><div class="line">## Docs: https://hexo.io/docs/configuration.html</div><div class="line">## Source: https://github.com/hexojs/hexo/</div><div class="line"></div><div class="line"># Site #站点信息</div><div class="line">title: PROSS # 标题</div><div class="line">subtitle: Great minds have purpose, others have only wishes. # 副标题</div><div class="line">description: 心有猛虎  细嗅蔷薇 # 站点描述，给搜索引擎看的</div><div class="line">author: 彭爽 # 作者</div><div class="line">language: zh-Hans # 语言</div><div class="line">timezone: Asia/shanghai # 时区</div><div class="line"></div><div class="line"># URL #链接格式</div><div class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</div><div class="line">url: http://yoursite.com # 网址</div><div class="line">root: / #根目录</div><div class="line">permalink: :year/:month/:day/:title/ # 文章的链接格式</div><div class="line">permalink_defaults: </div><div class="line">tag_dir:  # 标签目录</div><div class="line">archive_dir: archives # 存档目录</div><div class="line">category_dir: categories # 分类目录</div><div class="line">code_dir: downloads/code</div><div class="line"></div><div class="line"># Directory # 目录</div><div class="line">source_dir: source # 源文件目录</div><div class="line">public_dir: public # 生成的网页文件目录</div><div class="line"></div><div class="line"># Writing #写作</div><div class="line">new_post_name: :title.md # File name of new posts #新文章标题</div><div class="line">default_layout: post #默认的模板包括post、page、photo、draft(文章、页面、照片、草稿)</div><div class="line">titlecase: false # Transform title into titlecase #标题转换成大写</div><div class="line">external_link: true # Open external links in new tab #在新选项卡中打开连接</div><div class="line">filename_case: 0</div><div class="line">render_drafts: false</div><div class="line">post_asset_folder: true</div><div class="line">relative_link: false</div><div class="line">future: true</div><div class="line">highlight: # 语法高亮</div><div class="line">  enable: true # 是否启用</div><div class="line">  line_number: true # 显示行号</div><div class="line">  auto_detect: false</div><div class="line">  tab_replace:</div><div class="line">  </div><div class="line"># Home page setting</div><div class="line"># path: Root path for your blogs index page. (default = &apos;&apos;)</div><div class="line"># per_page: Posts displayed per page. (0 = disable pagination)</div><div class="line"># order_by: Posts order. (Order by date descending by default)</div><div class="line">index_generator:</div><div class="line">  path: &apos;&apos;</div><div class="line">  per_page: 10</div><div class="line">  order_by: -date</div><div class="line">  </div><div class="line"># Category &amp; Tag #分类和标签</div><div class="line">default_category: uncategorized # 默认分类</div><div class="line">category_map:</div><div class="line">tag_map:</div><div class="line"># Archives</div><div class="line">2: 开启分页</div><div class="line">1: 禁止分页</div><div class="line">0: 全部禁用</div><div class="line">archive: 2</div><div class="line">category: 2</div><div class="line">tag: 2</div><div class="line"></div><div class="line"># Date / Time format # 日期时间格式</div><div class="line">## Hexo uses Moment.js to parse and display date</div><div class="line">## You can customize the date format as defined in</div><div class="line">## http://momentjs.com/docs/#/displaying/format/</div><div class="line">date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/</div><div class="line">time_format: HH:mm:ss</div><div class="line"></div><div class="line"># Pagination # 分页</div><div class="line">## Set per_page to 0 to disable pagination</div><div class="line">per_page: 10 # 每页文字数，设置为0则是禁止分页</div><div class="line">pagination_dir: page</div><div class="line"></div><div class="line"># Disqus #评论</div><div class="line">disqus_shortname:</div><div class="line"></div><div class="line"># Extensions # 拓展插件</div><div class="line">## Plugins: https://hexo.io/plugins/</div><div class="line">## Themes: https://hexo.io/themes/</div><div class="line">theme: next #主题</div><div class="line">exclude_generator:</div><div class="line">plugins: # 插件，例如生成RSS和站点地图</div><div class="line"></div><div class="line"># Deployment # 部署</div><div class="line">## Docs: https://hexo.io/docs/deployment.html</div><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: https://github.com/prosscode/prosscode.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure><p><strong>着重几点介绍：</strong></p><ul><li><p>修改网站相关信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">title: PROSS</div><div class="line">subtitle: Great minds have purpose, others have only wishes. </div><div class="line">description: 心有猛虎  细嗅蔷薇</div><div class="line">author: 彭爽 </div><div class="line">language: zh-Hans</div><div class="line">timezone: Asia/shanghai</div></pre></td></tr></table></figure></li><li><p>配置部署（我的是prosscode，修改成自己的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: https://github.com/prosscode/prosscode.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure></li></ul><blockquote><p>1、_config.yml文件中每个参数的：后都要加一个空格</p></blockquote><hr><h2 id="发表文章"><a href="#发表文章" class="headerlink" title="发表文章"></a><strong>发表文章</strong></h2><p>在cmder或cmd中输入：<code>λ hexo new &quot;prosscodeTestArticle&quot;</code></p><p>得到结果：<code>INFO Created: F:\test\blog\source\_posts\prosscodeTestArticle.md</code></p><p>找到该文章，打开，使用markdown语法，该语法可以查看<a href="http://www.cnblogs.com/ProSS/p/6616988.html" target="_blank" rel="external">Markdown入门</a><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: prosscodeTestArticle</div><div class="line">date: 2017-09-02 17:56:09</div><div class="line">tags:</div><div class="line">categories:</div><div class="line"></div><div class="line">---</div><div class="line">This is a test article, welcome to focus on the author blog [1]: https://prosscode.github.io/</div></pre></td></tr></table></figure><p></p><p>然后保存，执行下列步骤：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">C:\HexoBlog\blog</div><div class="line">λ hexo clean</div><div class="line">INFO  Deleted database.</div><div class="line">INFO  Deleted public folder.</div><div class="line">`</div><div class="line">C:\HexoBlog\blog</div><div class="line">λ hexo generate</div><div class="line">INFO  Start processing</div><div class="line">INFO  Files loaded in 1.48 s</div><div class="line">...</div><div class="line">INFO  29 files generated in 4.27 s</div><div class="line">`</div><div class="line">C:\HexoBlog\blog</div><div class="line">λ hexo server</div><div class="line">INFO  Start processing</div><div class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</div></pre></td></tr></table></figure><p></p><p>这个时候，打开<a href="http://localhost:4000/" target="_blank" rel="external">localhost:4000</a>，发现刚才的文章已经成功了</p><blockquote><p>1、<code>hexo clean</code> 清除缓存，网页正常显示的情况下可以不用</p></blockquote><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a><strong>发布</strong></h2><p>刚我们只是在本地查看了博客，现在我们发布到网上，执行：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">C:\HexoBlog\blog</div><div class="line">npm install hexo-deployer-git --save</div><div class="line">...</div><div class="line"></div><div class="line">C:\HexoBlog\blog</div><div class="line">λ hexo deploy</div><div class="line">INFO  Deploying: git</div><div class="line">INFO  Clearing .deploy_git folder...</div><div class="line">INFO  Copying files from public folder...</div><div class="line">...</div></pre></td></tr></table></figure><p></p><p><img src="/2017/Hexo+GitHub博客搭建/7.png" alt=""></p><p>跳出Github登录，直接登录</p><p>然后输入进入浏览器输入<a href="https://prosscode.github.io/">https://yourname.github.io/</a></p><p>然后就可以看到已经发布了</p><p><a href="https://prosscode.github.io">我的测试博客</a></p><blockquote><p>1、部署前需要安装hexo-deployer-git。在此前版本模块功能是集成在hexo框架里，现在模块功能分开了，需要先安装再部署<br>2、<code>hexo deploy</code>部署，可简写为：<code>hexo d</code></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p><strong>发布文章的步骤：</strong><br>1、hexo new 文章名<br>2、Markdown语法编辑文章<br>3、部署发布</p><p><strong>简写Tips</strong></p><blockquote><p>1、hexo n “我的博客” == hexo new “我的博客” # 新建文章<br>2、hexo p == hexo publish<br>3、hexo g == hexo generate # 生成<br>4、hexo s == hexo server # 启动服务预览<br>5、hexo d == hexo deploy # 部署</p></blockquote><p>到这里已经完成了博客的搭建，但是还有很多需要设置和调整的。</p><p>也许你会发现，我的博客和刚刚搭建的不太一样，因为我修改了博客主题，增加了一些插件。</p><p>提供几个比较好的博文和主题推荐：<br>1.<a href="https://hexo.io/themes/" target="_blank" rel="external">Hexo主题介绍</a></p><p>2.<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">开始使用NexT主题</a>，我正在使用NexT主题下的NexT.Pisces v5.1.2。</p><p>3.<a href="http://blog.csdn.net/qq_33699981/article/details/72716951" target="_blank" rel="external">Hexo的next主题个性化教程：打造炫酷网站</a></p><p>4.Markdown编写推荐<a href="https://typora.io/" target="_blank" rel="external">Typora</a>和<a href="http://markdownpad.com/download.html" target="_blank" rel="external">MarkdownPad2</a></p><p>​</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Mar 17 2018 13:38:21 GMT+0800 (中国标准时间) --&gt;&lt;blockquote&gt;&lt;p&gt;Hexo框架&lt;/p&gt;&lt;p&gt;GitHub 托管&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="https://prosscode.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
