<!-- build time:Tue Jan 01 2019 12:09:27 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>几种定时调度的介绍与实现 · PROSS</title><meta name="description" content="几种定时调度的介绍与实现 - RukiapR0ss"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://pross.space/atom.xml" title="PROSS"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/prosscode" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">几种定时调度的介绍与实现</h1><div class="post-info">Jan 1, 2019</div><div class="post-content"><p>由需求产出的一篇文章，憋了很久。以下将会看到，使用Timer进行任务调度，用ScheduledExecutor和Calendar实现任务调度，Spring中的任务调度TaskScheduler，开源工具包Quartz的简单介绍。</p><a id="more"></a><h4 id="使用Timer任务调度"><a href="#使用Timer任务调度" class="headerlink" title="使用Timer任务调度"></a>使用Timer任务调度</h4><p>Timer是<code>java.util.Timer</code>提供的比较简单的调度工具，实现任务调度的核心是Timer和TimerTask。其中Timer负责在<code>schedule</code>方法中设定TimerTask任务，以及任务执行的起始时间<code>delay</code>和间隔执行的时间<code>period</code>；TimerTask负责创建需要调度的任务，开发者需要实现<code>run</code>方法，然后将其丢给Timer去执行即可。</p><p>下面这个例子，用不同的方法实现了两个任务调度，其中一个任务达到条件后使用<code>cancel</code>方法终止了调度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"><span class="keyword">import</span> java.util.Timer;</div><div class="line"><span class="keyword">import</span> java.util.TimerTask;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@describe</span>: timer调度</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span>:彭爽pross</span></div><div class="line"><span class="comment"> * <span class="doctag">@date</span>: 2018/12/28</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerDemo</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String taskName=<span class="string">""</span>;</div><div class="line">	<span class="comment">//构造方法</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">TimerDemo</span><span class="params">(String taskName)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>();</div><div class="line">		<span class="keyword">this</span>.taskName=taskName;</div><div class="line">	&#125;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"TimerTask "</span>+taskName+<span class="string">","</span>+<span class="keyword">new</span> Date());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Timer timer = <span class="keyword">new</span> Timer();</div><div class="line">		<span class="keyword">long</span> delay1 = <span class="number">1</span> * <span class="number">1000</span>;</div><div class="line">		<span class="keyword">long</span> period1 = <span class="number">1000</span>;</div><div class="line">		timer.schedule(<span class="keyword">new</span> TimerDemo(<span class="string">"task 1"</span>),delay1,period1);</div><div class="line"></div><div class="line">		<span class="keyword">long</span> delay2 = <span class="number">2</span> * <span class="number">1000</span>;</div><div class="line">		<span class="keyword">long</span> period2 = <span class="number">1000</span>;</div><div class="line">		timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</div><div class="line">			String taskName = <span class="string">"task 2"</span>;</div><div class="line">			<span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				i++;</div><div class="line">				System.out.println(<span class="string">"TimerTask "</span>+taskName+<span class="string">","</span>+<span class="keyword">new</span> Date());</div><div class="line">				<span class="keyword">if</span>(i&gt;<span class="number">2</span>)&#123;</div><div class="line">					cancel();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;,delay2,period2);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>控制变量<code>i</code>大于等于2后，任务调度被终止，只剩下一个任务。输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">TimerTask task <span class="number">1</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">25</span> CST <span class="number">2018</span></div><div class="line">TimerTask task <span class="number">2</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">26</span> CST <span class="number">2018</span></div><div class="line">TimerTask task <span class="number">1</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">26</span> CST <span class="number">2018</span></div><div class="line">TimerTask task <span class="number">2</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">27</span> CST <span class="number">2018</span></div><div class="line">TimerTask task <span class="number">1</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">27</span> CST <span class="number">2018</span></div><div class="line">TimerTask task <span class="number">2</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">28</span> CST <span class="number">2018</span></div><div class="line">TimerTask task <span class="number">1</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">28</span> CST <span class="number">2018</span></div><div class="line">TimerTask task <span class="number">1</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29</span> CST <span class="number">2018</span></div><div class="line">TimerTask task <span class="number">1</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">30</span> CST <span class="number">2018</span></div><div class="line">TimerTask task <span class="number">1</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">31</span> CST <span class="number">2018</span></div><div class="line">TimerTask task <span class="number">1</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">32</span> CST <span class="number">2018</span></div></pre></td></tr></table></figure><p>如果调整调度周期，会发现所有的任务都是同一个线程来调度的，多个任务是串行执行，前一个任务的延迟或异常都将会影响到之后的任务。下图是Timer类的结构。</p><p><img src="/archives/2019/01/01/timer.jpg" alt=""></p><p>我们从执行开始追溯源码，先进入<code>schedule</code>方法，发现最终是调用的<code>sched</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, <span class="keyword">long</span> period)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (delay &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Negative delay."</span>);</div><div class="line">        <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Non-positive period."</span>);</div><div class="line">    	<span class="comment">// schedule方法，最终调用sched()</span></div><div class="line">        sched(task, System.currentTimeMillis()+delay, -period);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>这里我们发现了<code>queue</code>和<code>thread</code>的踪影，给<code>queue</code>加上控制线程同步<code>synchronized</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> TaskQueue queue = <span class="keyword">new</span> TaskQueue();</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> TimerThread thread = <span class="keyword">new</span> TimerThread(queue);</div><div class="line">...</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sched</span><span class="params">(TimerTask task, <span class="keyword">long</span> time, <span class="keyword">long</span> period)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (time &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal execution time."</span>);</div><div class="line">        <span class="keyword">if</span> (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>))</div><div class="line">            period &gt;&gt;= <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span>(queue) &#123;</div><div class="line">            <span class="keyword">if</span> (!thread.newTasksMayBeScheduled)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Timer already cancelled."</span>);</div><div class="line">            <span class="keyword">synchronized</span>(task.lock) &#123;</div><div class="line">                <span class="keyword">if</span> (task.state != TimerTask.VIRGIN)</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</div><div class="line">                        <span class="string">"Task already scheduled or cancelled"</span>);</div><div class="line">                task.nextExecutionTime = time;</div><div class="line">                task.period = period;</div><div class="line">                task.state = TimerTask.SCHEDULED;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 满足执行条件，加入queue</span></div><div class="line">            queue.add(task);</div><div class="line">            <span class="keyword">if</span> (queue.getMin() == task)</div><div class="line">                queue.notify();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>我们继续看TaskThread的执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//执行mainLoop()开始调度任务</span></div><div class="line">            mainLoop();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">synchronized</span>(queue) &#123;</div><div class="line">               <span class="comment">/** </span></div><div class="line"><span class="comment">                * 当newTasksMayBeScheduled是false时</span></div><div class="line"><span class="comment">                * 在上面sched方法中会抛出IllegalStateException异常</span></div><div class="line"><span class="comment">                * 所以只能同一时间执行一个任务</span></div><div class="line"><span class="comment">                */</span></div><div class="line">                newTasksMayBeScheduled = <span class="keyword">false</span>;</div><div class="line">                queue.clear(); </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p><code>mainLoop</code>方法就不展开，这里展示核心代码段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span>(task.lock) &#123;</div><div class="line">    <span class="comment">// 查看任务状态</span></div><div class="line">    <span class="keyword">if</span> (task.state == TimerTask.CANCELLED) &#123;</div><div class="line">        queue.removeMin();</div><div class="line">        <span class="keyword">continue</span>;  <span class="comment">// No action required, poll queue again</span></div><div class="line">    &#125;</div><div class="line">    currentTime = System.currentTimeMillis();</div><div class="line">    executionTime = task.nextExecutionTime;</div><div class="line">    <span class="comment">// 比较时间</span></div><div class="line">    <span class="keyword">if</span> (taskFired = (executionTime&lt;=currentTime)) &#123;</div><div class="line">        <span class="comment">// 调度周期为0，removemin</span></div><div class="line">        <span class="keyword">if</span> (task.period == <span class="number">0</span>) &#123; <span class="comment">// Non-repeating, remove</span></div><div class="line">            queue.removeMin();</div><div class="line">            task.state = TimerTask.EXECUTED;</div><div class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// Repeating task, reschedule</span></div><div class="line">            queue.rescheduleMin(</div><div class="line">                task.period&lt;<span class="number">0</span> ? currentTime - task.period : executionTime + task.period);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>最后总结下，Timer 的设计核心是一个<code>TaskQueue</code>和一个<code>TaskThread</code>。Timer 将接收到的任务丢到自己的<code>TaskQueue</code>中，TaskQueue按照Task的最初执行时间进行排序。TimerThread在创建Timer时会启动成为一个守护线程。这个线程会轮询所有任务，找到一个最近要执行的任务，然后休眠，当到达最近要执行任务的开始时间点，TimerThread被唤醒并执行该任务。之后TimerThread更新最近一个要执行的任务，继续休眠。</p><p>Timer的优点在于简单易用，缺点除了单线程调度问题，还有使用的场景比较单一。比如，设置每星期二的16:38:10执行任务，Timer就不是太适用。</p><h4 id="用ScheduledExecutor和Calendar实现任务调度"><a href="#用ScheduledExecutor和Calendar实现任务调度" class="headerlink" title="用ScheduledExecutor和Calendar实现任务调度"></a>用ScheduledExecutor和Calendar实现任务调度</h4><p>这是两个东西组合使用，所以先简单介绍下<code>ScheduledExecutor</code></p><h5 id="ScheduledExecutor"><a href="#ScheduledExecutor" class="headerlink" title="ScheduledExecutor"></a>ScheduledExecutor</h5><p>与Timer比较，优化了任务执行方式，采用线程池并行执行，说到线程池，上篇文章有过一点介绍了。这里直接上代码例子，介绍看注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@describe</span>: ScheduledExecutor 任务调度</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span>:彭爽pross</span></div><div class="line"><span class="comment"> * <span class="doctag">@date</span>: 2018/12/28</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledExecutorDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"task 1"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// 初始化线程池</span></div><div class="line">		ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">10</span>);</div><div class="line">		<span class="comment">// task 1 ，scheduleAtFixedRate方法，需要指明时间单位，实现的是runnable</span></div><div class="line">        <span class="comment">// 所以每一个任务都是单独的一个线程</span></div><div class="line">		service.scheduleAtFixedRate(<span class="keyword">new</span> ScheduledExecutorDemo(),<span class="number">1000</span>,<span class="number">1000</span>, TimeUnit.SECONDS);</div><div class="line">		<span class="comment">// task 2</span></div><div class="line">		service.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				System.out.println(<span class="string">"task 2"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;,<span class="number">1000</span>,<span class="number">1000</span>,TimeUnit.SECONDS);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>关于日历类<code>Calendar</code>就不做详细讲解，我们来看看怎么Calendar+ScheduledExecutor解决较为复杂的调度。</p><h5 id="实现每周五12点调度任务"><a href="#实现每周五12点调度任务" class="headerlink" title="实现每周五12点调度任务"></a>实现每周五12点调度任务</h5><p>代码一现，其义自见。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Calendar;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@describe</span>:</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span>:彭爽pross</span></div><div class="line"><span class="comment"> * <span class="doctag">@date</span>: 2018/12/27</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledExecuteCalendar</span> </span>&#123;</div><div class="line">	<span class="comment">// 初始化线程池</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">10</span>);</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line"><span class="comment">	 * 计算从当前时间currentDate开始，</span></div><div class="line"><span class="comment">	 * 满足条件dayOfWeek, hourOfDay,minuteOfHour, secondOfMinite的最近时间</span></div><div class="line"><span class="comment">	 * <span class="doctag">@return</span></span></div><div class="line"><span class="comment">	 */</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Calendar <span class="title">getEarliestDate</span><span class="params">(Calendar currentDate, <span class="keyword">int</span> dayOfWeek,</span></span></div><div class="line"><span class="function"><span class="params">	                                <span class="keyword">int</span> hourOfDay, <span class="keyword">int</span> minuteOfHour, <span class="keyword">int</span> secondOfMinite)</span> </span>&#123;</div><div class="line">		<span class="comment">//计算当前时间的WEEK_OF_YEAR,DAY_OF_WEEK, HOUR_OF_DAY, MINUTE,SECOND等各个字段值</span></div><div class="line">		<span class="keyword">int</span> currentWeekOfYear = currentDate.get(Calendar.WEEK_OF_YEAR);</div><div class="line">		<span class="keyword">int</span> currentDayOfWeek = currentDate.get(Calendar.DAY_OF_WEEK);</div><div class="line">		<span class="keyword">int</span> currentHour = currentDate.get(Calendar.HOUR_OF_DAY);</div><div class="line">		<span class="keyword">int</span> currentMinute = currentDate.get(Calendar.MINUTE);</div><div class="line">		<span class="keyword">int</span> currentSecond = currentDate.get(Calendar.SECOND);</div><div class="line"></div><div class="line">		<span class="comment">//如果输入条件中的dayOfWeek小于当前日期的dayOfWeek,则WEEK_OF_YEAR需要推迟一周</span></div><div class="line">		<span class="keyword">boolean</span> weekLater = <span class="keyword">false</span>;</div><div class="line">		<span class="keyword">if</span> (dayOfWeek &lt; currentDayOfWeek) &#123;</div><div class="line">			weekLater = <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//当输入条件与当前日期的dayOfWeek相等时，输入条件中的 hourOfDay小于当前日期的 currentHour，则WEEK_OF_YEAR需要推迟一周</span></div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (dayOfWeek == currentDayOfWeek) &#123;</div><div class="line">			<span class="keyword">if</span> (hourOfDay &lt; currentHour) &#123;</div><div class="line">				weekLater = <span class="keyword">true</span>;</div><div class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (hourOfDay == currentHour) &#123;</div><div class="line">				<span class="comment">//当输入条件与当前日期的dayOfWeek, hourOfDay相等时，输入条件中的minuteOfHour小于当前日期currentMinute，则WEEK_OF_YEAR需要推迟一周</span></div><div class="line">				<span class="keyword">if</span> (minuteOfHour &lt; currentMinute) &#123;</div><div class="line">					weekLater = <span class="keyword">true</span>;</div><div class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (minuteOfHour == currentSecond) &#123;</div><div class="line">					<span class="comment">//当输入条件与当前日期的dayOfWeek, hourOfDay，minuteOfHour相等时，如果输入条件中的secondOfMinite小于当前日期的currentSecond，则WEEK_OF_YEAR需要推迟一周</span></div><div class="line">					<span class="keyword">if</span> (secondOfMinite &lt; currentSecond) &#123;</div><div class="line">						weekLater = <span class="keyword">true</span>;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (weekLater) &#123;</div><div class="line">			<span class="comment">//设置当前日期中的WEEK_OF_YEAR为当前周推迟一周</span></div><div class="line">			currentDate.set(Calendar.WEEK_OF_YEAR, currentWeekOfYear + <span class="number">1</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="comment">// 设置当前日期中的DAY_OF_WEEK,HOUR_OF_DAY,MINUTE,SECOND为输入条件中的值。</span></div><div class="line">		currentDate.set(Calendar.DAY_OF_WEEK, dayOfWeek);</div><div class="line">		currentDate.set(Calendar.HOUR_OF_DAY, hourOfDay);</div><div class="line">		currentDate.set(Calendar.MINUTE, minuteOfHour);</div><div class="line">		currentDate.set(Calendar.SECOND, secondOfMinite);</div><div class="line">		<span class="keyword">return</span> currentDate;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		ScheduledExecuteCalendar test = <span class="keyword">new</span> ScheduledExecuteCalendar();</div><div class="line">		<span class="comment">// 获取当前时间</span></div><div class="line">		Calendar currentDate = Calendar.getInstance();</div><div class="line">		<span class="keyword">long</span> currentDateLong = currentDate.getTime().getTime();</div><div class="line">		System.out.println(<span class="string">"当前日期： "</span> + currentDate.getTime().toString());</div><div class="line">		<span class="comment">// 计算满足条件的最近一次执行时间</span></div><div class="line">		Calendar earliestDate = test.getEarliestDate(currentDate, <span class="number">6</span>, <span class="number">12</span>, <span class="number">00</span>, <span class="number">00</span>);</div><div class="line">		<span class="comment">//计算第一次执行延迟时间</span></div><div class="line">		<span class="keyword">long</span> earliestDateLong = earliestDate.getTime().getTime();</div><div class="line">		<span class="keyword">long</span> delay = earliestDateLong - currentDateLong;</div><div class="line">		System.out.println(<span class="string">"下一次执行时间："</span>+earliestDate.getTime().toString());</div><div class="line">		<span class="comment">//计算执行周期为一星期</span></div><div class="line">		<span class="keyword">long</span> period = <span class="number">7</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</div><div class="line">		System.out.println(<span class="string">"等待执行..."</span>);</div><div class="line">		service.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				System.out.println(<span class="string">"Task ScheduledExecute"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;, delay, period, TimeUnit.MILLISECONDS); </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="Spring中的任务调度TaskScheduler"><a href="#Spring中的任务调度TaskScheduler" class="headerlink" title="Spring中的任务调度TaskScheduler"></a>Spring中的任务调度TaskScheduler</h4><p>TaskScheduler用于对Runnable的任务进行调度，其中包含多种实现，多数对任务进行调度的实现是<code>ThreadPoolTaskScheduler</code>；另外需要用到<code>Trigger</code>接口计算任务的下次执行时间；我们先看下Trigger接口的实现。</p><h5 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h5><p>Trigger接口定义如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Trigger</span> </span>&#123;</div><div class="line">	<span class="comment">/**</span></div><div class="line"><span class="comment">	 * Determine the next execution time according to the given trigger context.</span></div><div class="line"><span class="comment">	 * <span class="doctag">@param</span> triggerContext context object encapsulating last execution times</span></div><div class="line"><span class="comment">	 * and last completion time</span></div><div class="line"><span class="comment">	 * <span class="doctag">@return</span> the next execution time as defined by the trigger,</span></div><div class="line"><span class="comment">	 * or &#123;<span class="doctag">@code</span> null&#125; if the trigger won't fire anymore</span></div><div class="line"><span class="comment">	 */</span></div><div class="line">	<span class="meta">@Nullable</span></div><div class="line">	<span class="function">Date <span class="title">nextExecutionTime</span><span class="params">(TriggerContext triggerContext)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中提供了一个接口：<code>nextExecutionTime</code>来获取下次执行时间，接受的参数为TirggerContxt对象，这个参数对象能获取上次原本的计划时间 / 实际的执行时间 / 实际的完成时间，你问我是怎么知道？点进去看源码呀！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TriggerContext</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line"><span class="comment">	 * Return the last &lt;i&gt;scheduled&lt;/i&gt; execution time of the task,</span></div><div class="line"><span class="comment">	 * or &#123;<span class="doctag">@code</span> null&#125; if not scheduled before.</span></div><div class="line"><span class="comment">	 */</span></div><div class="line">	<span class="meta">@Nullable</span></div><div class="line">	<span class="function">Date <span class="title">lastScheduledExecutionTime</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line"><span class="comment">	 * Return the last &lt;i&gt;actual&lt;/i&gt; execution time of the task,</span></div><div class="line"><span class="comment">	 * or &#123;<span class="doctag">@code</span> null&#125; if not scheduled before.</span></div><div class="line"><span class="comment">	 */</span></div><div class="line">	<span class="meta">@Nullable</span></div><div class="line">	<span class="function">Date <span class="title">lastActualExecutionTime</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line"><span class="comment">	 * Return the last completion time of the task,</span></div><div class="line"><span class="comment">	 * or &#123;<span class="doctag">@code</span> null&#125; if not scheduled before.</span></div><div class="line"><span class="comment">	 */</span></div><div class="line">	<span class="meta">@Nullable</span></div><div class="line">	<span class="function">Date <span class="title">lastCompletionTime</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>继续返回来，来看看有哪些实现类继承Trigger接口（IDEA中快捷键，<code>option + command +B</code> / <code>ctrl + alt + B</code> ）；第一个是<code>CronTrigger</code>，通过<code>Crob</code>表达式来生成的调度计划，还可以选择是否加上时区。</p><p>举例：工作日的9-17点之间，每隔30分钟执行一次；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> CronTrigger(<span class="string">"0 0/30 9-17 * * MON-FRI"</span>)</div></pre></td></tr></table></figure><p>第二个实现类是<code>PeriodicTrigger</code>，也用于定期执行，有两种模式可以选择：<code>setFixedRate</code>，boolean类型，默认是false。和 <code>setInitialDelay</code>，long类型，表示启动任务后延迟多长时间开始执行第一次任务。最后就是构造方法，参数<code>period</code>，long类型，表示间隔时长；参数<code>timeUnit</code>，TimeUnit类型，指定时长单位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Specify whether the periodic interval should be measured between the</span></div><div class="line"><span class="comment"> * scheduled start times rather than between actual completion times.</span></div><div class="line"><span class="comment"> * The latter, "fixed delay" behavior, is the default.</span></div><div class="line"><span class="comment"> * 简明总结为：两次任务开始时间的间隔为指定的时长(period)。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFixedRate</span><span class="params">(<span class="keyword">boolean</span> fixedRate)</span> </span>&#123;</div><div class="line">	<span class="keyword">this</span>.fixedRate = fixedRate;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Specify the delay for the initial execution. It will be evaluated in</span></div><div class="line"><span class="comment"> * terms of this trigger's &#123;<span class="doctag">@link</span> TimeUnit&#125;. If no time unit was explicitly</span></div><div class="line"><span class="comment"> * provided upon instantiation, the default is milliseconds.</span></div><div class="line"><span class="comment"> * 简明总结为：设置启动调度后，设置执行第一次任务的延迟时间。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInitialDelay</span><span class="params">(<span class="keyword">long</span> initialDelay)</span> </span>&#123;</div><div class="line">	<span class="keyword">this</span>.initialDelay = <span class="keyword">this</span>.timeUnit.toMillis(initialDelay);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>TaskScheduler</strong></p><p>TaskScheduler接口的实现类有ThreadPoolTaskScheduler，其中还有ConcurrentTaskScheduler，DefaultManagedTaskScheduler，TimerManagerTaskScheduler，这里重要说下默认的实现类ThreadPoolTaskScheduler。</p><p>在大多数场景下都使用它来进行任务调度，除了实现TaskScheduler接口外，还包含了一些对ThreadPoolTaskScheduler进行操作的接口：<code>AsyncListenableTaskExecutor</code>和<code>SchedulingTaskExecutor</code>。其常用的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 设置线程池大小，默认为poolsize=1。</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPoolSize</span><span class="params">(<span class="keyword">int</span> poolSize)</span> </span>&#123;</div><div class="line">		Assert.isTrue(poolSize &gt; <span class="number">0</span>, <span class="string">"'poolSize' must be 1 or higher"</span>);</div><div class="line">		<span class="keyword">this</span>.poolSize = poolSize;</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.scheduledExecutor <span class="keyword">instanceof</span> ScheduledThreadPoolExecutor) &#123;</div><div class="line">			((ScheduledThreadPoolExecutor) <span class="keyword">this</span>.scheduledExecutor).setCorePoolSize(poolSize);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="comment">// 异常处理起</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setErrorHandler</span><span class="params">(ErrorHandler errorHandler)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.errorHandler = errorHandler;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取当前活动的线程数</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getActiveCount</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.scheduledExecutor == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="comment">// Not initialized yet: assume no active threads.</span></div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> getScheduledThreadPoolExecutor().getActiveCount();</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="comment">// 提交执行任务，需继承必须重写的方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</div><div class="line">		Executor executor = getScheduledExecutor();</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			executor.execute(errorHandlingTask(task, <span class="keyword">false</span>));</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> TaskRejectedException(<span class="string">"Executor ["</span> + executor + <span class="string">"] did not accept task: "</span> + task, ex);</div><div class="line">        &#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="comment">// 提交执行一次的任务，并且返回一个Future对象供判断任务状态使用</span></div><div class="line"><span class="comment">// submit/submitListenable</span></div><div class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</div><div class="line">		ExecutorService executor = getScheduledExecutor();</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="keyword">return</span> executor.submit(errorHandlingTask(task, <span class="keyword">false</span>));</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> TaskRejectedException(<span class="string">"Executor ["</span> + executor + <span class="string">"] did not accept task: "</span> + task, ex);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure><p>Spring中提供<code>Scheduled</code>注解来实现快捷的任务调度，需要注意的是必须使用<code>@EnableScheduling</code>注解启用对<code>@Scheduled</code>注解的支持，@EnableScheduling必须使用在项目中某一个被<code>@Configuration</code>注解的类上，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableScheduling</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBConfiguration</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Scheduled注解用在方法下，用户表示这个方法将会被调度，所注解的方法返回类型最好是<code>void</code>类型，否则它的返回值将不会被TaskScheduler所使用。同时，如果需要参数对象，需要通过依赖注入的方式引用，其中包含：</p><ul><li>cron：使用cron语法来指定调度计划</li><li>zone：指定时区，默认为本时区</li><li>fixedDelay：指定fixedDelay的值，默认单位是毫秒</li><li>fixedRate：指定上一次任务开始时间到下一次任务开始时间的间隔时间，单位默认是毫秒</li><li>initialDelay：设置初始延迟时间</li></ul><p>其中cron / fixedDelay / fixedRate三个属性必须且只能出现一个，下面举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Service</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleService</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ScheduleService.class);</div><div class="line"></div><div class="line">    <span class="meta">@Scheduled</span>(fixedRate = <span class="number">4000</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSchedule</span><span class="params">()</span> </span>&#123;</div><div class="line">        logger.info(<span class="string">"TestSchedule begins to execute!"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            logger.error(<span class="string">"TestSchedule has been interrupted!"</span>, e);</div><div class="line">            <span class="keyword">return</span>;  </div><div class="line">        &#125;</div><div class="line">        logger.info(<span class="string">"TestSchedule execution was completed!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>还有一个直接在Spring Boot中使用<code>@Autowired</code>注解的方式，直接实现threadPoolTaskScheduler，实现动态的添加、修改、删除定时任务，也是实现需求考虑的方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledFuture;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</div><div class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;</div><div class="line"><span class="keyword">import</span> org.springframework.scheduling.support.CronTrigger;</div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</div><div class="line"> </div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@describe</span>:</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span>:彭爽pross</span></div><div class="line"><span class="comment"> * <span class="doctag">@date</span>: 2018/12/28</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicTaskController</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> ThreadPoolTaskScheduler threadPoolTaskScheduler;</div><div class="line">   </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 在ScheduledFuture中cancel可以停止定时任务。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> ScheduledFuture&lt;?&gt; future;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * ThreadPoolTaskScheduler：线程池任务调度类，能够开启线程池进行任务调度。</span></div><div class="line"><span class="comment">     * ThreadPoolTaskScheduler.schedule()方法会创建一个定时计划ScheduledFuture，在这个方法需要添加两个参数，Runnable（线程接口类） 和CronTrigger（定时任务触发器）</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span></span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolTaskScheduler <span class="title">threadPoolTaskScheduler</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolTaskScheduler();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 启动任务，每五秒钟执行一次</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/startTask"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">startCron</span><span class="params">()</span> </span>&#123;</div><div class="line">       future = threadPoolTaskScheduler.schedule(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				System.out.println(<span class="string">"execute task"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;, <span class="keyword">new</span> CronTrigger(<span class="string">"0/5 * * * * *"</span>));</div><div class="line">       System.out.println(<span class="string">"DynamicTaskController.startCron()"</span>);</div><div class="line">       <span class="keyword">return</span> <span class="string">"startTask"</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 启此任务</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/stopTask"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">stopCron</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (future != <span class="keyword">null</span>) &#123;</div><div class="line">           future.cancel(<span class="keyword">true</span>);</div><div class="line">       &#125;</div><div class="line">       System.out.println(<span class="string">"DynamicTaskController.stopCron()"</span>);</div><div class="line">       <span class="keyword">return</span> <span class="string">"stopTask"</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 变更任务间隔，再次启动</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/changeCron"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">changeCron</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="comment">// 先停止，在开启</span></div><div class="line">       stopCron();</div><div class="line">       future = threadPoolTaskScheduler.schedule(<span class="keyword">new</span> MyRunnable(), <span class="keyword">new</span> CronTrigger(<span class="string">"*/10 * * * * *"</span>));</div><div class="line">       System.out.println(<span class="string">"DynamicTaskController.changeCron()"</span>);</div><div class="line">       <span class="keyword">return</span> <span class="string">"changeCron"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="简单介绍开源工具包Quartz"><a href="#简单介绍开源工具包Quartz" class="headerlink" title="简单介绍开源工具包Quartz"></a>简单介绍开源工具包Quartz</h4><p>Quartz 可以满足更多更复杂的调度需求，设计的核心类包括 Scheduler，Job 以及Trigger。其中Job 负责定义需要执行的任务，Trigger 负责设置调度策略，Scheduler 将二者组装在一起，并触发任务开始执行，除了Job其它的核心类大多已经简单介绍过，下面看看Job。</p><p><strong>Job</strong></p><p>使用者只需要创建一个 Job 的继承类，实现<code>execute</code>方法。<code>JobDetail</code>负责封装 Job 以及 Job 的属性，并将其提供给 Scheduler 作为参数。每次 Scheduler 执行任务时，首先会创建一个 Job 的实例，然后再调用 execute 方法执行。Quartz 没有为 Job 设计带参数的构造函数，因此需要通过额外的 JobDataMap 来存储 Job 的属性。JobDataMap 可以存储任意数量的 Key，Value键值对。</p><p>举个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.quartz.Job;</div><div class="line"><span class="keyword">import</span> org.quartz.JobDetail;</div><div class="line"><span class="keyword">import</span> org.quartz.JobExecutionContext;</div><div class="line"><span class="keyword">import</span> org.quartz.JobExecutionException;</div><div class="line"><span class="keyword">import</span> org.quartz.Scheduler;</div><div class="line"><span class="keyword">import</span> org.quartz.SchedulerFactory;</div><div class="line"><span class="keyword">import</span> org.quartz.Trigger;</div><div class="line"><span class="keyword">import</span> org.quartz.helpers.TriggerUtils;</div><div class="line"> </div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@describe</span>: 创建一个MyJob类，实现Job接口</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span>:彭爽pross</span></div><div class="line"><span class="comment"> * <span class="doctag">@date</span>: 2018/12/29</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJob</span> <span class="keyword">implements</span> <span class="title">Job</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Scheduler scheduler = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">// 创建一个JobDetail实例</span></div><div class="line">			JobBuilder jobBuilder = JobBuilder.newJob(MyJob.class);</div><div class="line">			jobBuilder.withDescription(<span class="string">"test read desc."</span>);</div><div class="line">			JobDetail jobDetail = jobBuilder.build();</div><div class="line"></div><div class="line">			<span class="comment">// 创建一个调度规则, 每3s运行一次</span></div><div class="line">			SimpleScheduleBuilder simpleBuilder = SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(<span class="number">3</span>).repeatForever();</div><div class="line">			Trigger trigger = TriggerBuilder.newTrigger().withSchedule(simpleBuilder).startNow().build();</div><div class="line"></div><div class="line">			<span class="comment">// 从工厂中获取一个调度器Scheduler</span></div><div class="line">			SchedulerFactory schedulerFactory = <span class="keyword">new</span> StdSchedulerFactory();</div><div class="line">			scheduler = schedulerFactory.getScheduler();</div><div class="line"></div><div class="line">			<span class="comment">// 注册jobDetail, trigger到调度器Scheduler</span></div><div class="line">			scheduler.scheduleJob(jobDetail, trigger);</div><div class="line"></div><div class="line">			<span class="comment">// 开始执行Job</span></div><div class="line">			scheduler.start();</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e1) &#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="comment">// 出异常了, 停止执行Job</span></div><div class="line">				scheduler.shutdown();</div><div class="line">			&#125; <span class="keyword">catch</span> (SchedulerException e2) &#123;</div><div class="line">				e2.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			e1.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException</span>&#123;</div><div class="line">		String description = jobExecutionContext.getJobDetail().getDescription();</div><div class="line">		System.out.println(<span class="string">"定时Job开始运行: "</span> + description);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Quartz还可以和Spring整合使用，需要创建一个具体的作业任务的实现类，使用JobDetailFactoryBean来管理作业任务。具体就不细致展开，这篇文章篇幅已经够长了，</p><p>几种定时调度的介绍和实现暂时就写这么多。</p><p>完。</p></div></article></div></main><footer><div class="paginator"><a href="/archives/2018/12/22/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname="pross-space",disqus_identifier="archives/2019/01/01/",disqus_title="几种定时调度的介绍与实现",disqus_url="https://pross.space/archives/2019/01/01/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><script id="dsq-count-scr" src="//pross-space.disqus.com/count.js" async></script><div class="copyright"><p>© 2017 - 2019 <a href="https://pross.space">RukiapR0ss</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html><!-- rebuild by neat -->