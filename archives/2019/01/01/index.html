<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>几种定时调度的介绍与实现 | PROSS</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 5.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">几种定时调度的介绍与实现</h1><a id="logo" href="/.">PROSS</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a class="current" href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a><a href="/daysmatter/"><i class="fa fa-home"> DaysMatter</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">几种定时调度的介绍与实现</h1><div class="post-meta">Jan 1, 2019</div><a class="disqus-comment-count" data-disqus-identifier="archives/2019/01/01/" href="/archives/2019/01/01/#disqus_thread"></a><div class="post-content"><p>由需求产出的一篇文章，憋了很久。以下将会看到，使用Timer进行任务调度，用ScheduledExecutor和Calendar实现任务调度，Spring中的任务调度TaskScheduler，开源工具包Quartz的简单介绍。</p>
<a id="more"></a>

<h4 id="使用Timer任务调度"><a href="#使用Timer任务调度" class="headerlink" title="使用Timer任务调度"></a>使用Timer任务调度</h4><p>Timer是<code>java.util.Timer</code>提供的比较简单的调度工具，实现任务调度的核心是Timer和TimerTask。其中Timer负责在<code>schedule</code>方法中设定TimerTask任务，以及任务执行的起始时间<code>delay</code>和间隔执行的时间<code>period</code>；TimerTask负责创建需要调度的任务，开发者需要实现<code>run</code>方法，然后将其丢给Timer去执行即可。</p>
<p>下面这个例子，用不同的方法实现了两个任务调度，其中一个任务达到条件后使用<code>cancel</code>方法终止了调度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span>: timer调度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:彭爽pross</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2018/12/28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerDemo</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String taskName=<span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="comment">//构造方法</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">TimerDemo</span><span class="params">(String taskName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.taskName=taskName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;TimerTask &quot;</span>+taskName+<span class="string">&quot;,&quot;</span>+<span class="keyword">new</span> Date());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">		<span class="keyword">long</span> delay1 = <span class="number">1</span> * <span class="number">1000</span>;</span><br><span class="line">		<span class="keyword">long</span> period1 = <span class="number">1000</span>;</span><br><span class="line">		timer.schedule(<span class="keyword">new</span> TimerDemo(<span class="string">&quot;task 1&quot;</span>),delay1,period1);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">long</span> delay2 = <span class="number">2</span> * <span class="number">1000</span>;</span><br><span class="line">		<span class="keyword">long</span> period2 = <span class="number">1000</span>;</span><br><span class="line">		timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">			String taskName = <span class="string">&quot;task 2&quot;</span>;</span><br><span class="line">			<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				i++;</span><br><span class="line">				System.out.println(<span class="string">&quot;TimerTask &quot;</span>+taskName+<span class="string">&quot;,&quot;</span>+<span class="keyword">new</span> Date());</span><br><span class="line">				<span class="keyword">if</span>(i&gt;<span class="number">2</span>)&#123;</span><br><span class="line">					cancel();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,delay2,period2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制变量<code>i</code>大于等于2后，任务调度被终止，只剩下一个任务。输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TimerTask task <span class="number">1</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">25</span> CST <span class="number">2018</span></span><br><span class="line">TimerTask task <span class="number">2</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">26</span> CST <span class="number">2018</span></span><br><span class="line">TimerTask task <span class="number">1</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">26</span> CST <span class="number">2018</span></span><br><span class="line">TimerTask task <span class="number">2</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">27</span> CST <span class="number">2018</span></span><br><span class="line">TimerTask task <span class="number">1</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">27</span> CST <span class="number">2018</span></span><br><span class="line">TimerTask task <span class="number">2</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">28</span> CST <span class="number">2018</span></span><br><span class="line">TimerTask task <span class="number">1</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">28</span> CST <span class="number">2018</span></span><br><span class="line">TimerTask task <span class="number">1</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29</span> CST <span class="number">2018</span></span><br><span class="line">TimerTask task <span class="number">1</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">30</span> CST <span class="number">2018</span></span><br><span class="line">TimerTask task <span class="number">1</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">31</span> CST <span class="number">2018</span></span><br><span class="line">TimerTask task <span class="number">1</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">32</span> CST <span class="number">2018</span></span><br></pre></td></tr></table></figure>
<p>如果调整调度周期，会发现所有的任务都是同一个线程来调度的，多个任务是串行执行，前一个任务的延迟或异常都将会影响到之后的任务。下图是Timer类的结构。</p>
<p><img src="%E5%87%A0%E7%A7%8D%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%9E%E7%8E%B0%5Ctimer.jpg"></p>
<p>我们从执行开始追溯源码，先进入<code>schedule</code>方法，发现最终是调用的<code>sched</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, <span class="keyword">long</span> period)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delay &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Negative delay.&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Non-positive period.&quot;</span>);</span><br><span class="line">    	<span class="comment">// schedule方法，最终调用sched()</span></span><br><span class="line">        sched(task, System.currentTimeMillis()+delay, -period);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们发现了<code>queue</code>和<code>thread</code>的踪影，给<code>queue</code>加上控制线程同步<code>synchronized</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TaskQueue queue = <span class="keyword">new</span> TaskQueue();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TimerThread thread = <span class="keyword">new</span> TimerThread(queue);</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sched</span><span class="params">(TimerTask task, <span class="keyword">long</span> time, <span class="keyword">long</span> period)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (time &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal execution time.&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>))</span><br><span class="line">            period &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(queue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!thread.newTasksMayBeScheduled)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Timer already cancelled.&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span>(task.lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (task.state != TimerTask.VIRGIN)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        <span class="string">&quot;Task already scheduled or cancelled&quot;</span>);</span><br><span class="line">                task.nextExecutionTime = time;</span><br><span class="line">                task.period = period;</span><br><span class="line">                task.state = TimerTask.SCHEDULED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 满足执行条件，加入queue</span></span><br><span class="line">            queue.add(task);</span><br><span class="line">            <span class="keyword">if</span> (queue.getMin() == task)</span><br><span class="line">                queue.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们继续看TaskThread的执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行mainLoop()开始调度任务</span></span><br><span class="line">            mainLoop();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(queue) &#123;</span><br><span class="line">               <span class="comment">/** </span></span><br><span class="line"><span class="comment">                * 当newTasksMayBeScheduled是false时</span></span><br><span class="line"><span class="comment">                * 在上面sched方法中会抛出IllegalStateException异常</span></span><br><span class="line"><span class="comment">                * 所以只能同一时间执行一个任务</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                newTasksMayBeScheduled = <span class="keyword">false</span>;</span><br><span class="line">                queue.clear(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>mainLoop</code>方法就不展开，这里展示核心代码段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(task.lock) &#123;</span><br><span class="line">    <span class="comment">// 查看任务状态</span></span><br><span class="line">    <span class="keyword">if</span> (task.state == TimerTask.CANCELLED) &#123;</span><br><span class="line">        queue.removeMin();</span><br><span class="line">        <span class="keyword">continue</span>;  <span class="comment">// No action required, poll queue again</span></span><br><span class="line">    &#125;</span><br><span class="line">    currentTime = System.currentTimeMillis();</span><br><span class="line">    executionTime = task.nextExecutionTime;</span><br><span class="line">    <span class="comment">// 比较时间</span></span><br><span class="line">    <span class="keyword">if</span> (taskFired = (executionTime&lt;=currentTime)) &#123;</span><br><span class="line">        <span class="comment">// 调度周期为0，removemin</span></span><br><span class="line">        <span class="keyword">if</span> (task.period == <span class="number">0</span>) &#123; <span class="comment">// Non-repeating, remove</span></span><br><span class="line">            queue.removeMin();</span><br><span class="line">            task.state = TimerTask.EXECUTED;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// Repeating task, reschedule</span></span><br><span class="line">            queue.rescheduleMin(</span><br><span class="line">                task.period&lt;<span class="number">0</span> ? currentTime - task.period : executionTime + task.period);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最后总结下，Timer 的设计核心是一个<code>TaskQueue</code>和一个<code>TaskThread</code>。Timer 将接收到的任务丢到自己的<code>TaskQueue</code>中，TaskQueue按照Task的最初执行时间进行排序。TimerThread在创建Timer时会启动成为一个守护线程。这个线程会轮询所有任务，找到一个最近要执行的任务，然后休眠，当到达最近要执行任务的开始时间点，TimerThread被唤醒并执行该任务。之后TimerThread更新最近一个要执行的任务，继续休眠。</p>
<p>Timer的优点在于简单易用，缺点除了单线程调度问题，还有使用的场景比较单一。比如，设置每星期二的16:38:10执行任务，Timer就不是太适用。</p>
<h4 id="用ScheduledExecutor和Calendar实现任务调度"><a href="#用ScheduledExecutor和Calendar实现任务调度" class="headerlink" title="用ScheduledExecutor和Calendar实现任务调度"></a>用ScheduledExecutor和Calendar实现任务调度</h4><p>这是两个东西组合使用，所以先简单介绍下<code>ScheduledExecutor</code></p>
<h5 id="ScheduledExecutor"><a href="#ScheduledExecutor" class="headerlink" title="ScheduledExecutor"></a>ScheduledExecutor</h5><p>与Timer比较，优化了任务执行方式，采用线程池并行执行，说到线程池，上篇文章有过一点介绍了。这里直接上代码例子，介绍看注释。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span>: ScheduledExecutor 任务调度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:彭爽pross</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2018/12/28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledExecutorDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;task 1&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 初始化线程池</span></span><br><span class="line">		ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">		<span class="comment">// task 1 ，scheduleAtFixedRate方法，需要指明时间单位，实现的是runnable</span></span><br><span class="line">        <span class="comment">// 所以每一个任务都是单独的一个线程</span></span><br><span class="line">		service.scheduleAtFixedRate(<span class="keyword">new</span> ScheduledExecutorDemo(),<span class="number">1000</span>,<span class="number">1000</span>, TimeUnit.SECONDS);</span><br><span class="line">		<span class="comment">// task 2</span></span><br><span class="line">		service.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;task 2&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,<span class="number">1000</span>,<span class="number">1000</span>,TimeUnit.SECONDS);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于日历类<code>Calendar</code>就不做详细讲解，我们来看看怎么Calendar+ScheduledExecutor解决较为复杂的调度。</p>
<h5 id="实现每周五12点调度任务"><a href="#实现每周五12点调度任务" class="headerlink" title="实现每周五12点调度任务"></a>实现每周五12点调度任务</h5><p>代码一现，其义自见。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:彭爽pross</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2018/12/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledExecuteCalendar</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 初始化线程池</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 计算从当前时间currentDate开始，</span></span><br><span class="line"><span class="comment">	 * 满足条件dayOfWeek, hourOfDay,minuteOfHour, secondOfMinite的最近时间</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Calendar <span class="title">getEarliestDate</span><span class="params">(Calendar currentDate, <span class="keyword">int</span> dayOfWeek,</span></span></span><br><span class="line"><span class="function"><span class="params">	                                <span class="keyword">int</span> hourOfDay, <span class="keyword">int</span> minuteOfHour, <span class="keyword">int</span> secondOfMinite)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//计算当前时间的WEEK_OF_YEAR,DAY_OF_WEEK, HOUR_OF_DAY, MINUTE,SECOND等各个字段值</span></span><br><span class="line">		<span class="keyword">int</span> currentWeekOfYear = currentDate.get(Calendar.WEEK_OF_YEAR);</span><br><span class="line">		<span class="keyword">int</span> currentDayOfWeek = currentDate.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">		<span class="keyword">int</span> currentHour = currentDate.get(Calendar.HOUR_OF_DAY);</span><br><span class="line">		<span class="keyword">int</span> currentMinute = currentDate.get(Calendar.MINUTE);</span><br><span class="line">		<span class="keyword">int</span> currentSecond = currentDate.get(Calendar.SECOND);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//如果输入条件中的dayOfWeek小于当前日期的dayOfWeek,则WEEK_OF_YEAR需要推迟一周</span></span><br><span class="line">		<span class="keyword">boolean</span> weekLater = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (dayOfWeek &lt; currentDayOfWeek) &#123;</span><br><span class="line">			weekLater = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//当输入条件与当前日期的dayOfWeek相等时，输入条件中的 hourOfDay小于当前日期的 currentHour，则WEEK_OF_YEAR需要推迟一周</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (dayOfWeek == currentDayOfWeek) &#123;</span><br><span class="line">			<span class="keyword">if</span> (hourOfDay &lt; currentHour) &#123;</span><br><span class="line">				weekLater = <span class="keyword">true</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (hourOfDay == currentHour) &#123;</span><br><span class="line">				<span class="comment">//当输入条件与当前日期的dayOfWeek, hourOfDay相等时，输入条件中的minuteOfHour小于当前日期currentMinute，则WEEK_OF_YEAR需要推迟一周</span></span><br><span class="line">				<span class="keyword">if</span> (minuteOfHour &lt; currentMinute) &#123;</span><br><span class="line">					weekLater = <span class="keyword">true</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (minuteOfHour == currentSecond) &#123;</span><br><span class="line">					<span class="comment">//当输入条件与当前日期的dayOfWeek, hourOfDay，minuteOfHour相等时，如果输入条件中的secondOfMinite小于当前日期的currentSecond，则WEEK_OF_YEAR需要推迟一周</span></span><br><span class="line">					<span class="keyword">if</span> (secondOfMinite &lt; currentSecond) &#123;</span><br><span class="line">						weekLater = <span class="keyword">true</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (weekLater) &#123;</span><br><span class="line">			<span class="comment">//设置当前日期中的WEEK_OF_YEAR为当前周推迟一周</span></span><br><span class="line">			currentDate.set(Calendar.WEEK_OF_YEAR, currentWeekOfYear + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 设置当前日期中的DAY_OF_WEEK,HOUR_OF_DAY,MINUTE,SECOND为输入条件中的值。</span></span><br><span class="line">		currentDate.set(Calendar.DAY_OF_WEEK, dayOfWeek);</span><br><span class="line">		currentDate.set(Calendar.HOUR_OF_DAY, hourOfDay);</span><br><span class="line">		currentDate.set(Calendar.MINUTE, minuteOfHour);</span><br><span class="line">		currentDate.set(Calendar.SECOND, secondOfMinite);</span><br><span class="line">		<span class="keyword">return</span> currentDate;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ScheduledExecuteCalendar test = <span class="keyword">new</span> ScheduledExecuteCalendar();</span><br><span class="line">		<span class="comment">// 获取当前时间</span></span><br><span class="line">		Calendar currentDate = Calendar.getInstance();</span><br><span class="line">		<span class="keyword">long</span> currentDateLong = currentDate.getTime().getTime();</span><br><span class="line">		System.out.println(<span class="string">&quot;当前日期： &quot;</span> + currentDate.getTime().toString());</span><br><span class="line">		<span class="comment">// 计算满足条件的最近一次执行时间</span></span><br><span class="line">		Calendar earliestDate = test.getEarliestDate(currentDate, <span class="number">6</span>, <span class="number">12</span>, <span class="number">00</span>, <span class="number">00</span>);</span><br><span class="line">		<span class="comment">//计算第一次执行延迟时间</span></span><br><span class="line">		<span class="keyword">long</span> earliestDateLong = earliestDate.getTime().getTime();</span><br><span class="line">		<span class="keyword">long</span> delay = earliestDateLong - currentDateLong;</span><br><span class="line">		System.out.println(<span class="string">&quot;下一次执行时间：&quot;</span>+earliestDate.getTime().toString());</span><br><span class="line">		<span class="comment">//计算执行周期为一星期</span></span><br><span class="line">		<span class="keyword">long</span> period = <span class="number">7</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;等待执行...&quot;</span>);</span><br><span class="line">		service.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;Task ScheduledExecute&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, delay, period, TimeUnit.MILLISECONDS); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Spring中的任务调度TaskScheduler"><a href="#Spring中的任务调度TaskScheduler" class="headerlink" title="Spring中的任务调度TaskScheduler"></a>Spring中的任务调度TaskScheduler</h4><p>TaskScheduler用于对Runnable的任务进行调度，其中包含多种实现，多数对任务进行调度的实现是<code>ThreadPoolTaskScheduler</code>；另外需要用到<code>Trigger</code>接口计算任务的下次执行时间；我们先看下Trigger接口的实现。</p>
<h5 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h5><p>Trigger接口定义如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Trigger</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine the next execution time according to the given trigger context.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> triggerContext context object encapsulating last execution times</span></span><br><span class="line"><span class="comment">	 * and last completion time</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the next execution time as defined by the trigger,</span></span><br><span class="line"><span class="comment">	 * or &#123;<span class="doctag">@code</span> null&#125; if the trigger won&#x27;t fire anymore</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">Date <span class="title">nextExecutionTime</span><span class="params">(TriggerContext triggerContext)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中提供了一个接口：<code>nextExecutionTime</code>来获取下次执行时间，接受的参数为TirggerContxt对象，这个参数对象能获取上次原本的计划时间 / 实际的执行时间 / 实际的完成时间，你问我是怎么知道？点进去看源码呀！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TriggerContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the last &lt;i&gt;scheduled&lt;/i&gt; execution time of the task,</span></span><br><span class="line"><span class="comment">	 * or &#123;<span class="doctag">@code</span> null&#125; if not scheduled before.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">Date <span class="title">lastScheduledExecutionTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the last &lt;i&gt;actual&lt;/i&gt; execution time of the task,</span></span><br><span class="line"><span class="comment">	 * or &#123;<span class="doctag">@code</span> null&#125; if not scheduled before.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">Date <span class="title">lastActualExecutionTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the last completion time of the task,</span></span><br><span class="line"><span class="comment">	 * or &#123;<span class="doctag">@code</span> null&#125; if not scheduled before.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">Date <span class="title">lastCompletionTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续返回来，来看看有哪些实现类继承Trigger接口（IDEA中快捷键，<code>option + command +B</code> / <code>ctrl + alt + B</code> ）；第一个是<code>CronTrigger</code>，通过<code>Crob</code>表达式来生成的调度计划，还可以选择是否加上时区。</p>
<p>举例：工作日的9-17点之间，每隔30分钟执行一次；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> CronTrigger(<span class="string">&quot;0 0/30 9-17 * * MON-FRI&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>第二个实现类是<code>PeriodicTrigger</code>，也用于定期执行，有两种模式可以选择：<code>setFixedRate</code>，boolean类型，默认是false。和 <code>setInitialDelay</code>，long类型，表示启动任务后延迟多长时间开始执行第一次任务。最后就是构造方法，参数<code>period</code>，long类型，表示间隔时长；参数<code>timeUnit</code>，TimeUnit类型，指定时长单位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Specify whether the periodic interval should be measured between the</span></span><br><span class="line"><span class="comment"> * scheduled start times rather than between actual completion times.</span></span><br><span class="line"><span class="comment"> * The latter, &quot;fixed delay&quot; behavior, is the default.</span></span><br><span class="line"><span class="comment"> * 简明总结为：两次任务开始时间的间隔为指定的时长(period)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFixedRate</span><span class="params">(<span class="keyword">boolean</span> fixedRate)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.fixedRate = fixedRate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Specify the delay for the initial execution. It will be evaluated in</span></span><br><span class="line"><span class="comment"> * terms of this trigger&#x27;s &#123;<span class="doctag">@link</span> TimeUnit&#125;. If no time unit was explicitly</span></span><br><span class="line"><span class="comment"> * provided upon instantiation, the default is milliseconds.</span></span><br><span class="line"><span class="comment"> * 简明总结为：设置启动调度后，设置执行第一次任务的延迟时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInitialDelay</span><span class="params">(<span class="keyword">long</span> initialDelay)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.initialDelay = <span class="keyword">this</span>.timeUnit.toMillis(initialDelay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>TaskScheduler</strong></p>
<p>TaskScheduler接口的实现类有ThreadPoolTaskScheduler，其中还有ConcurrentTaskScheduler，DefaultManagedTaskScheduler，TimerManagerTaskScheduler，这里重要说下默认的实现类ThreadPoolTaskScheduler。</p>
<p>在大多数场景下都使用它来进行任务调度，除了实现TaskScheduler接口外，还包含了一些对ThreadPoolTaskScheduler进行操作的接口：<code>AsyncListenableTaskExecutor</code>和<code>SchedulingTaskExecutor</code>。其常用的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置线程池大小，默认为poolsize=1。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPoolSize</span><span class="params">(<span class="keyword">int</span> poolSize)</span> </span>&#123;</span><br><span class="line">		Assert.isTrue(poolSize &gt; <span class="number">0</span>, <span class="string">&quot;&#x27;poolSize&#x27; must be 1 or higher&quot;</span>);</span><br><span class="line">		<span class="keyword">this</span>.poolSize = poolSize;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.scheduledExecutor <span class="keyword">instanceof</span> ScheduledThreadPoolExecutor) &#123;</span><br><span class="line">			((ScheduledThreadPoolExecutor) <span class="keyword">this</span>.scheduledExecutor).setCorePoolSize(poolSize);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异常处理起</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setErrorHandler</span><span class="params">(ErrorHandler errorHandler)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.errorHandler = errorHandler;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前活动的线程数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getActiveCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.scheduledExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// Not initialized yet: assume no active threads.</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> getScheduledThreadPoolExecutor().getActiveCount();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交执行任务，需继承必须重写的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">		Executor executor = getScheduledExecutor();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			executor.execute(errorHandlingTask(task, <span class="keyword">false</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> TaskRejectedException(<span class="string">&quot;Executor [&quot;</span> + executor + <span class="string">&quot;] did not accept task: &quot;</span> + task, ex);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交执行一次的任务，并且返回一个Future对象供判断任务状态使用</span></span><br><span class="line"><span class="comment">// submit/submitListenable</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">		ExecutorService executor = getScheduledExecutor();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> executor.submit(errorHandlingTask(task, <span class="keyword">false</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> TaskRejectedException(<span class="string">&quot;Executor [&quot;</span> + executor + <span class="string">&quot;] did not accept task: &quot;</span> + task, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>Spring中提供<code>Scheduled</code>注解来实现快捷的任务调度，需要注意的是必须使用<code>@EnableScheduling</code>注解启用对<code>@Scheduled</code>注解的支持，@EnableScheduling必须使用在项目中某一个被<code>@Configuration</code>注解的类上，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Scheduled注解用在方法下，用户表示这个方法将会被调度，所注解的方法返回类型最好是<code>void</code>类型，否则它的返回值将不会被TaskScheduler所使用。同时，如果需要参数对象，需要通过依赖注入的方式引用，其中包含：</p>
<ul>
<li>cron：使用cron语法来指定调度计划</li>
<li>zone：指定时区，默认为本时区</li>
<li>fixedDelay：指定fixedDelay的值，默认单位是毫秒</li>
<li>fixedRate：指定上一次任务开始时间到下一次任务开始时间的间隔时间，单位默认是毫秒</li>
<li>initialDelay：设置初始延迟时间</li>
</ul>
<p>其中cron / fixedDelay / fixedRate三个属性必须且只能出现一个，下面举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ScheduleService.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 4000)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSchedule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;TestSchedule begins to execute!&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;TestSchedule has been interrupted!&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">&quot;TestSchedule execution was completed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一个直接在Spring Boot中使用<code>@Autowired</code>注解的方式，直接实现threadPoolTaskScheduler，实现动态的添加、修改、删除定时任务，也是实现需求考虑的方案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledFuture;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.support.CronTrigger;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:彭爽pross</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2018/12/28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicTaskController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskScheduler threadPoolTaskScheduler;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在ScheduledFuture中cancel可以停止定时任务。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ScheduledFuture&lt;?&gt; future;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ThreadPoolTaskScheduler：线程池任务调度类，能够开启线程池进行任务调度。</span></span><br><span class="line"><span class="comment">     * ThreadPoolTaskScheduler.schedule()方法会创建一个定时计划ScheduledFuture，在这个方法需要添加两个参数，Runnable（线程接口类） 和CronTrigger（定时任务触发器）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolTaskScheduler <span class="title">threadPoolTaskScheduler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolTaskScheduler();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动任务，每五秒钟执行一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/startTask&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">startCron</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       future = threadPoolTaskScheduler.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;execute task&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="keyword">new</span> CronTrigger(<span class="string">&quot;0/5 * * * * *&quot;</span>));</span><br><span class="line">       System.out.println(<span class="string">&quot;DynamicTaskController.startCron()&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;startTask&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启此任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/stopTask&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">stopCron</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (future != <span class="keyword">null</span>) &#123;</span><br><span class="line">           future.cancel(<span class="keyword">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;DynamicTaskController.stopCron()&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;stopTask&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 变更任务间隔，再次启动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/changeCron&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">changeCron</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 先停止，在开启</span></span><br><span class="line">       stopCron();</span><br><span class="line">       future = threadPoolTaskScheduler.schedule(<span class="keyword">new</span> MyRunnable(), <span class="keyword">new</span> CronTrigger(<span class="string">&quot;*/10 * * * * *&quot;</span>));</span><br><span class="line">       System.out.println(<span class="string">&quot;DynamicTaskController.changeCron()&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;changeCron&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="简单介绍开源工具包Quartz"><a href="#简单介绍开源工具包Quartz" class="headerlink" title="简单介绍开源工具包Quartz"></a>简单介绍开源工具包Quartz</h4><p>Quartz 可以满足更多更复杂的调度需求，设计的核心类包括 Scheduler，Job 以及Trigger。其中Job 负责定义需要执行的任务，Trigger 负责设置调度策略，Scheduler 将二者组装在一起，并触发任务开始执行，除了Job其它的核心类大多已经简单介绍过，下面看看Job。</p>
<p><strong>Job</strong></p>
<p>使用者只需要创建一个 Job 的继承类，实现<code>execute</code>方法。<code>JobDetail</code>负责封装 Job 以及 Job 的属性，并将其提供给 Scheduler 作为参数。每次 Scheduler 执行任务时，首先会创建一个 Job 的实例，然后再调用 execute 方法执行。Quartz 没有为 Job 设计带参数的构造函数，因此需要通过额外的 JobDataMap 来存储 Job 的属性。JobDataMap 可以存储任意数量的 Key，Value键值对。</p>
<p>举个例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.Job;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobDetail;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionContext;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionException;</span><br><span class="line"><span class="keyword">import</span> org.quartz.Scheduler;</span><br><span class="line"><span class="keyword">import</span> org.quartz.SchedulerFactory;</span><br><span class="line"><span class="keyword">import</span> org.quartz.Trigger;</span><br><span class="line"><span class="keyword">import</span> org.quartz.helpers.TriggerUtils;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span>: 创建一个MyJob类，实现Job接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:彭爽pross</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2018/12/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJob</span> <span class="keyword">implements</span> <span class="title">Job</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scheduler scheduler = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 创建一个JobDetail实例</span></span><br><span class="line">			JobBuilder jobBuilder = JobBuilder.newJob(MyJob.class);</span><br><span class="line">			jobBuilder.withDescription(<span class="string">&quot;test read desc.&quot;</span>);</span><br><span class="line">			JobDetail jobDetail = jobBuilder.build();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 创建一个调度规则, 每3s运行一次</span></span><br><span class="line">			SimpleScheduleBuilder simpleBuilder = SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(<span class="number">3</span>).repeatForever();</span><br><span class="line">			Trigger trigger = TriggerBuilder.newTrigger().withSchedule(simpleBuilder).startNow().build();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 从工厂中获取一个调度器Scheduler</span></span><br><span class="line">			SchedulerFactory schedulerFactory = <span class="keyword">new</span> StdSchedulerFactory();</span><br><span class="line">			scheduler = schedulerFactory.getScheduler();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 注册jobDetail, trigger到调度器Scheduler</span></span><br><span class="line">			scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 开始执行Job</span></span><br><span class="line">			scheduler.start();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 出异常了, 停止执行Job</span></span><br><span class="line">				scheduler.shutdown();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (SchedulerException e2) &#123;</span><br><span class="line">				e2.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			e1.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException</span>&#123;</span><br><span class="line">		String description = jobExecutionContext.getJobDetail().getDescription();</span><br><span class="line">		System.out.println(<span class="string">&quot;定时Job开始运行: &quot;</span> + description);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Quartz还可以和Spring整合使用，需要创建一个具体的作业任务的实现类，使用JobDetailFactoryBean来管理作业任务。具体就不细致展开，这篇文章篇幅已经够长了，</p>
<p>几种定时调度的介绍和实现暂时就写这么多。</p>
<p>完。 </p>
</div><div class="tags"><a href="/tags/Java/">Java</a></div><div class="post-nav"><a class="pre" href="/archives/2019/01/13/">散列表</a><a class="next" href="/archives/2018/12/22/">Java线程池</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://pross.space/archives/2019/01/01/';
    this.page.identifier = 'archives/2019/01/01/';
    this.page.title = '几种定时调度的介绍与实现';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//pross-space.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//pross-space.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://pross-space.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://pross.space"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/Thrift/" style="font-size: 15px;">Thrift</a> <a href="/tags/HDFS/" style="font-size: 15px;">HDFS</a> <a href="/tags/Hadoop/" style="font-size: 15px;">Hadoop</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/Hibernate/" style="font-size: 15px;">Hibernate</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/LeetCode/" style="font-size: 15px;">LeetCode</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/MapReduce/" style="font-size: 15px;">MapReduce</a> <a href="/tags/Spark/" style="font-size: 15px;">Spark</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/%E9%9A%8F%E7%AC%94%E6%9D%82%E8%AE%B0/" style="font-size: 15px;">随笔杂记</a> <a href="/tags/Swagger/" style="font-size: 15px;">Swagger</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 15px;">数据结构</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/RPC/" style="font-size: 15px;">RPC</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/archives/2019/07/09/">Apache-Thrift-Thrift-Thrift</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/2019/06/17/">远程过程调用</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/2019/02/02/">使用Swagger2构建RESTful API</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/2019/01/13/">散列表</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/2019/01/01/">几种定时调度的介绍与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/2018/12/22/">Java线程池</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/2018/12/16/">大O表示法</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/2018/11/11/">你所忽视的排序算法（下）</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/2018/10/27/">你所忽视的排序算法（上）</a></li><li class="post-list-item"><a class="post-list-link" href="/archives/2018/09/28/">相见</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://github.com/prosscode" title="Github" target="_blank">Github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">PROSS.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>