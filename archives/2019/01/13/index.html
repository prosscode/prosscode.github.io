<!-- build time:Sun Jan 13 2019 22:59:28 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>散列表 · PROSS</title><meta name="description" content="散列表 - RukiapR0ss"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://pross.space/atom.xml" title="PROSS"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/prosscode" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">散列表</h1><div class="post-info">Jan 13, 2019</div><div class="post-content"><p>关于算法系列，在前面已经整理过大O表示法和排序算法相关的文章，今天接着上次的话说一说散列表（Hash Table，也叫哈希表），顺便穿插和另外两种基本的数据结构，数组和链表比较；并在最后介绍良好的散列函数——SHA函数的使用。这三种基本数据结构，可简可繁，在写代码时候都是比较频繁使用的，那我们先从散列表开始入手。</p><a id="more"></a><p>散列表是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做<code>散列函数</code>，存放记录的数组称做<code>散列表</code>。散列表是最有用的基本数据结构之一，我们需要总结散列表：实现、冲突和散列函数。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>举个例子：为了查找电话薄中某人的号码，可以创建一个按照人名首字母顺序排列的表，即建立人名<code>x</code>到首字母<code>F(x)</code>的一个函数关系。在首字母为p的表中查找姓”彭”的电话号码，那么就可以直接调用这样的函数关系，查找的就快很多。这里使用人名作为了关键字，也就是键（Key）；”取首字母”是这个例子中散列函数的函数法则<code>F()</code>，存放首字母的表对应<code>散列表</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 使用dict创建散列表phone_list</span></div><div class="line">In [<span class="number">1</span>]: phone_list = dict()</div><div class="line">In [<span class="number">2</span>]: phone_list[<span class="string">"pross"</span>] = <span class="number">15013637180</span></div><div class="line"><span class="comment"># 映射关系输出</span></div><div class="line">In [<span class="number">3</span>]: print(phone_list[<span class="string">"pross"</span>])</div><div class="line"><span class="number">15013637180</span></div></pre></td></tr></table></figure><p>在代码中，散列表是由键和值组成，在散列表<code>phone_list</code>中，键为姓名，值为电话号码。散列表将键映射到值。为了对比性能，我们先介绍下数组。</p><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>在计算机科学中，<code>数据数据结构(array date structure)</code>，简称为数组；是由相同类型的元素的集合所组成的数据结构，分配一块<code>连续的内存</code>来存储，可以利用元素的索引可以计算出该元素对应的存储地址。</p><p>还是举个例子：现在有个需求，要编写一个管理待办事项的应用程序，需要将这些待办事项存储在内存中，如果我们选用数组来存储，那么意味着所有的待办事项在内存中都是相连的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 定义数组</span></div><div class="line">In [<span class="number">7</span>]: do_list_tup = ()</div><div class="line">In [<span class="number">8</span>]: do_list_tup = (<span class="string">'1.doing homework'</span>,<span class="string">'2.have dinner'</span>)</div><div class="line"><span class="comment"># 输出索引为1的待办事项</span></div><div class="line">In [<span class="number">9</span>]: print(do_list_tup[<span class="number">1</span>])</div><div class="line"><span class="number">2.</span>have dinner</div><div class="line"><span class="comment"># 输出所有待办事项</span></div><div class="line">In [<span class="number">10</span>]: print(do_list_tup)</div><div class="line">(<span class="string">'1.doing homework'</span>, <span class="string">'2.have dinner'</span>)</div></pre></td></tr></table></figure><p>如果现在我要先玩滑板，在写作业呢？那么就需要把后面的每一个待办事项都得挪一个位置才行，如果待办事项有很多很多，这种操作就有点麻烦了。接下来，我们得继续看看<code>链表(Linked list)</code>。</p><h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><p>链表中的元素可以存储在任何地方，链表的每个元素都存储了下一个元素的地址，从而使一系列的随机内存地址串在了一起。这就很方便的上面出现的问题了：直接在前面插入玩滑板，链表会存储一个标记表示下一个待办事项是写作业。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 定义列表</span></div><div class="line">In [<span class="number">11</span>]: do_list = []</div><div class="line">In [<span class="number">12</span>]: do_list = [<span class="string">'1.doing homework'</span>,<span class="string">'2.have dinner'</span>]</div><div class="line"><span class="comment"># 取出索引为1的元素</span></div><div class="line">In [<span class="number">13</span>]: print(do_list[<span class="number">1</span>])</div><div class="line"><span class="number">2.</span>have dinner</div><div class="line"><span class="comment"># 插入插入待办事项</span></div><div class="line">In [<span class="number">15</span>]: do_list.insert(<span class="number">0</span>,<span class="string">'3.Skateboarding'</span>)</div><div class="line"><span class="comment"># 输出</span></div><div class="line">In [<span class="number">16</span>]: print(do_list)</div><div class="line">[<span class="string">'3.Skateboarding'</span>, <span class="string">'1.doing homework'</span>, <span class="string">'2.have dinner'</span>]</div></pre></td></tr></table></figure><p>链表的优势在插入元素方面，数组的优势在于查找，散列表的优势又是什么呢？</p><h5 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h5><p>在这里对这三种基本数据结构做一个对比总结，还记得前面说过的大O表示法么？</p><p>在平均情况下，散列表执行各种操作的时间都为O(1)，O(1)被称为<code>常量时间</code>。简单的查找的运行时间为线性时间，二分查找的速度更快，所需要的时间为对数时间，在散列表中查找所花费的时间是常量时间。这意味着无论散列表包含一个元素还是一亿个元素，从其中获取数据所需要的时间都是相同；其实从数组中获取一个元素所需要的时间也是固定的。</p><p>我们来将散列表同数组，链表来比较一下：</p><p><img src="/archives/2019/01/13/pic.jpg" alt=""></p><p>在平均情况下，散列表的查找速度和数组一样快，而插入和删除速度与链表一样快，在最糟的情况下，散列表的各种操作的速度都很慢。因此在使用散列表时，需要避开最糟糕的情况，也就是需要避开冲突。</p><h4 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h4><p>散列表中存在冲突，什么冲突？就是散列函数不可能总是将不同的键均匀的映射到数组的不同的位置。拿在开头举的一个例子，为了查找电话薄中某人的号码，我们创建一个按照人名首字母顺序排列的表，以p开头姓名存储到对应的散列表位置中，但是以p开头的姓名也不是只有一个，就需要给多个键分配到了同一个位置，这样就会造成冲突。</p><p>最简单的是：如果两个键映射到同一个位置，就在这个位置存储一个链表。这样<code>pross</code>和<code>paul</code>都会映射到同一个位置，在访问以p开头的姓名时，速度依然很快。但需要查询pross的电话号码时，速度就慢一些；如果散列表存储的链表很长，散列表的速度也将急剧的下降。</p><p>处理冲突比较好的办法有：较低的填充因子和良好的散列函数。</p><p><strong>填充因子</strong></p><p>散列表的填充因子很容易计算：</p><pre><code>$$填装因子 = \frac{散列表包含的元素数}{位置总数}$$    
</code></pre><p>散列表使用数组来存储数据，因此需要计算数组中被占用的位置数，填装因子大于1，意味着元素超过了位置总数。一旦填充因子开始增大，就需要在散列表中添加位置，也就是<code>调整长度(resizing)</code>，长度增加，填装因子就变低，发生的冲突的可能性越小，散列表的性能也就越高。</p><blockquote><p>一个不错的经验规则是：一旦填充因子大于0.7，就需要调整列表的长度。</p><p>调整长度的时间开销很大。</p></blockquote><p><strong>良好的散列函数</strong></p><p>一个糟糕的散列函数就会让值扎堆，导致大量的冲突；选择一个良好的散列函数，能够让数组中的值呈均匀分布，解决冲突。这里介绍<code>SHA函数</code>，这也是扩展知识中的心动之处。</p><p><code>安全散列算法</code>（英语：Secure Hash Algorithm，缩写为SHA）是一个密码散列函数家族（SHA-0，SHA-1，SHA-2，SHA-3），能计算出一个数字消息所对应到的，长度固定的字符串的算法（又称消息摘要）。且若输入的消息不同，它们对应到不同字符串的机率极高。</p><p>SHA是一个散列函数，它生成一个散列值，用于创建散列表的散列函数根据字符串生成数组索引，而SHA根据字符串生成另外一个字符串，对于每个字符串，SHA生成的散列值极大可能不同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">20</span>]: <span class="keyword">import</span> hashlib</div><div class="line"><span class="comment"># 使用sha256</span></div><div class="line">In [<span class="number">21</span>]: hash = hashlib.sha256()</div><div class="line">In [<span class="number">22</span>]: hash.update(<span class="string">'pross'</span>.encode(<span class="string">'utf-8'</span>))</div><div class="line">In [<span class="number">24</span>]: hash.hexdigest()</div><div class="line">Out[<span class="number">25</span>]: <span class="string">'58f8b4db8a8d80bc485de70a57912ddcf8a2fa93e698e2ce346f9f54d859af5f'</span></div><div class="line">...</div></pre></td></tr></table></figure><p><strong>扩展</strong>：密钥导出和扩展算法是为安全密码散列设计的，类似<code>hashlib.sha256()</code>这种简单算法不能有效抵御暴力破解，一个好的密码散列函数必须是可调节的，耗时的，并包含盐。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">26</span>]: <span class="keyword">import</span> hashlib</div><div class="line"><span class="comment"># 密钥导出，pbkdf2_hmac(hash_name, password, salt, iterations, dklen=None)提供了使用PKCS#5填充的pbkdf2算法，使用HMAC作为伪随机函数</span></div><div class="line">In [<span class="number">27</span>]: dk = hashlib.pbkdf2_hmac(<span class="string">'sha256'</span>,<span class="string">b'pross'</span>,<span class="string">b'salt'</span>,<span class="number">1000</span>)</div><div class="line">In [<span class="number">28</span>]: <span class="keyword">import</span> binascii</div><div class="line">In [<span class="number">29</span>]: binascii.hexlify(dk)</div><div class="line">Out[<span class="number">29</span>]: <span class="string">b'07c8f073bc2484c6163cd7c44d8d35f0b6ffc16e3b907df16bf8d292ccd176f9'</span></div></pre></td></tr></table></figure><p>字符串hash_name是HMAC的哈希摘要算法的所需名称，例如：sha1或sha256；password和salt为字节的缓冲区，所以应该将password限制在合理的长度（1024）；iterations的数量基于散列算法和计算能力来选择。截至2013年，建议至少100,000次迭代的SHA-256；dklen是导出密钥的长度，如果dklen=None，则使用散列算法hash_name的摘要大小，例如，64为SHA-512的摘要大小。</p><p>快乐的时光总是短暂的，散列表及其各种天马行空的扩展知识就介绍到这。</p><p>完。</p></div></article></div></main><footer><div class="paginator"><a href="/archives/2019/01/01/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname="pross-space",disqus_identifier="archives/2019/01/13/",disqus_title="散列表",disqus_url="https://pross.space/archives/2019/01/13/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><script id="dsq-count-scr" src="//pross-space.disqus.com/count.js" async></script><div class="copyright"><p>© 2017 - 2019 <a href="https://pross.space">RukiapR0ss</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html><!-- rebuild by neat -->