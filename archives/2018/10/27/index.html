<!-- build time:Sat Feb 02 2019 01:03:48 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>你所忽视的排序算法（上） · PROSS</title><meta name="description" content="你所忽视的排序算法（上） - RukiapR0ss"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://pross.space/atom.xml" title="PROSS"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/prosscode" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">你所忽视的排序算法（上）</h1><div class="post-info">Oct 27, 2018</div><div class="post-content"><blockquote><p>算法（algorithm），在数学（算学）和计算机科学之中，为任何良定义的具体计算步骤的一个序列，常用语计算，数据处理和自动推理。精确而言，算法是一个表示为有限长列表的有效方法。算法应包含清晰定义的指令用于计算函数。</p><p>——<a href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95" target="_blank" rel="external">维基百科</a></p></blockquote><a id="more"></a><p>程序猿圈子里似乎都默然这样的一个等式：程序=数据结构+算法。思考起来，就感觉相当于：作文=语法+词语。这句话相当出名，因为这是1986年尼古拉斯赵四（逃）在获得图灵奖时说的一句话，现在听起来，似乎没有什么不正确的。当然，这就好比当年牛顿在1687年提出万有引力一样，现在看起来是废话一样，但是当时这句话确定奠定了程序的基础概念。</p><p>所以我们就来讲讲算法，那么问题来了，什么是算法呢？喏，开头已经引用了维基百科的对算法的定义，下面接而来了一段解释：</p><blockquote><p>算法中的指令描述的是一个<a href="https://zh.wikipedia.org/wiki/%E8%A8%88%E7%AE%97" target="_blank" rel="external">计算</a>，当其运行时能从一个初始状态和初始输入（可能为空）开始，经过一系列<strong>有限</strong>而清晰定义的状态最终产生<strong>输出</strong>并<strong>停止</strong>于一个终态。一个状态到另一个状态的转移不一定是确定的。随机化算法在内的一些算法，包含了一些随机输入。</p></blockquote><p>看懂了吗？别急别急，没看懂没关系，我也不是很理解；不过没关系，我们用一句通俗的话来阐释一下：<strong>算法（Algorithm）就是解决问题的方法</strong>。所以我们就这样来理解就好了。</p><p>在InfoQ上有一篇文章《计算机科学最重要的32个算法》，介绍了二分查找法（Binary Search），快速傅里叶变换（Fast Fourier transform，FFT），哈希算法（Hashing），堆排序（Heaps）等等，有兴趣的可以看看。当然，我也是在学习中。今天这篇文章是算法系列的第一篇，我们先从排序算法（Sort）开始。</p><p>计划是来介绍十大常见的排序算法，为了控制文章篇幅，分上下两篇来介绍，一些算法定义解释和动态图过程分析展示大多来自于自由全面的维基百科。此文为上篇，介绍算法引入排序以及介绍部分简单的排序算法。下篇介绍剩余的排序算法和下一章预告。</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>排序算法大致可以分为两大类：<strong>非线性时间比较类排序和线性时间非比较类</strong>。前者是通过比较来决定元素间的次序，其时间复杂度不能突破O（nlogn）；后者不通过比较来决定元素间的次序，但是可以突破基于比较排序的时间下界，以线性时间运行。有点数学基础的各位看官很好理解线性和非线性的区别，以及过程中会提到复杂度，这里不在赘述，以后有机会单开一篇介绍。</p><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>冒泡排序（Bubble Sort）是一种简单的排序算法，常作为程序设计入门算法介绍。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><p><strong>逻辑描述</strong></p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ul><p><strong>代码实现</strong></p><p>比较常见的算法，代码略。</p><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><p><strong>逻辑描述</strong></p><p>N个记录的直接选择排序可经过N-1趟直接选择排序得到有序结果。</p><ul><li>初始状态：无序区为R[1…n]，有序区为空</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R[i..n]。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区</li><li>n-1趟结束，数组有序化了</li></ul><p><strong>代码实现</strong></p><p>比较常见的算法，代码略。</p><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p><strong>插入排序</strong>（Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p><strong>逻辑描述</strong></p><p>插入排序在实现上，通常采用in-place排序（即只需用到<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e66384bc40452c5452f33563fe0e27e803b0cc21" alt="{\displaystyle O(1)}">的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置后</li><li>重复步骤2~5</li></ol><p><strong>代码实现</strong></p><p>比较常见的算法，代码略。</p><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>希尔排序（Shell Sort），也称递减增量排序算法，是插入排序的一种更高效的改进版本。</p><p><strong>逻辑描述</strong></p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1</li><li>按增量序列个数k，对序列进行k趟排序</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度</li></ul><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.pross.sort;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@describe</span>:</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span>:彭爽pross</span></div><div class="line"><span class="comment"> * <span class="doctag">@date</span>: 2018/10/27</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] shellSort(<span class="keyword">int</span>[] array) &#123;</div><div class="line">		<span class="keyword">int</span> i;</div><div class="line">		<span class="keyword">int</span> j;</div><div class="line">		<span class="keyword">int</span> temp;</div><div class="line">		<span class="comment">//自定义间隔序列</span></div><div class="line">		<span class="keyword">int</span> number = array.length / <span class="number">2</span>;</div><div class="line">		<span class="keyword">while</span> (number &gt;= <span class="number">1</span>) &#123;</div><div class="line">			<span class="keyword">for</span> (i = number; i &lt; array.length; i++) &#123;</div><div class="line">				temp = array[i];</div><div class="line">				j = i - number;</div><div class="line">				<span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; array[j] &lt; temp) &#123;</div><div class="line">					array[j + number] = array[j];</div><div class="line">					j = j - number;</div><div class="line">				&#125;</div><div class="line">				array[j + number] = temp;</div><div class="line">			&#125;</div><div class="line">			number = number / <span class="number">2</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> array;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>算法分析</strong></p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：1.插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；2.但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。</p><p>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。</p><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>归并排序（Merge sort，或mergesort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p><p><strong>逻辑描述</strong></p><ol><li>将序列每相邻两个数字进行归并操作，形成<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/284284713ad8f1ba13458b896c87efc4b9b7df9c" alt="{\displaystyle ceil(n/2)}">个序列，排序后每个序列包含两/一个元素</li><li>若此时序列数不是一个则将上述序列再次归并，形成<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0f7b6be8e0c402e981a78d573dc3072c3d24a3c4" alt="{\displaystyle ceil(n/4)}">个序列，每个序列包含四/三个元素</li><li>重复第2步操作，直到所有元素排序完毕，即序列数为1</li></ol><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.pross.sort;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@describe</span>: 归并排序</span></div><div class="line"><span class="comment"> * <span class="doctag">@author</span>:彭爽pross</span></div><div class="line"><span class="comment"> * <span class="doctag">@date</span>: 2018/10/27</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] arr) &#123;</div><div class="line">		<span class="keyword">int</span>[] orderedArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; arr.length * <span class="number">2</span>; i *= <span class="number">2</span>) &#123;</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (arr.length + i - <span class="number">1</span>) / i; j++) &#123;</div><div class="line">				<span class="keyword">int</span> left = i * j;</div><div class="line">				<span class="keyword">int</span> mid = left + i / <span class="number">2</span> &gt;= arr.length ? (arr.length - <span class="number">1</span>) : (left + i / <span class="number">2</span>);</div><div class="line">				<span class="keyword">int</span> right = i * (j + <span class="number">1</span>) - <span class="number">1</span> &gt;= arr.length ? (arr.length - <span class="number">1</span>) : (i * (j + <span class="number">1</span>) - <span class="number">1</span>);</div><div class="line">				<span class="keyword">int</span> start = left, l = left, m = mid;</div><div class="line">				<span class="keyword">while</span> (l &lt; mid &amp;&amp; m &lt;= right) &#123;</div><div class="line">					<span class="keyword">if</span> (arr[l] &lt; arr[m]) &#123;</div><div class="line">						orderedArr[start++] = arr[l++];</div><div class="line">					&#125; <span class="keyword">else</span> &#123;</div><div class="line">						orderedArr[start++] = arr[m++];</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">while</span> (l &lt; mid)</div><div class="line">					orderedArr[start++] = arr[l++];</div><div class="line">				<span class="keyword">while</span> (m &lt;= right)</div><div class="line">					orderedArr[start++] = arr[m++];</div><div class="line">				System.arraycopy(orderedArr, left, arr, left, right - left + <span class="number">1</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> orderedArr;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>上篇介绍了，冒泡排序，选择排序，插入排序，希尔排序和归并排序。</p><p>所有代码可以在<a href="https://github.com/prosscode/java-learning-case/tree/master/algorithm/src/main/java/org/pross/sort" target="_blank" rel="external">我的Github</a>查阅。</p></blockquote></div></article></div></main><footer><div class="paginator"><a href="/archives/2018/11/11/" class="prev">PREV</a><a href="/archives/2018/09/28/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname="pross-space",disqus_identifier="archives/2018/10/27/",disqus_title="你所忽视的排序算法（上）",disqus_url="https://pross.space/archives/2018/10/27/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><script id="dsq-count-scr" src="//pross-space.disqus.com/count.js" async></script><div class="copyright"><p>© 2017 - 2019 <a href="https://pross.space">RukiapR0ss</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html><!-- rebuild by neat -->