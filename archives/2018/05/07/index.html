<!-- build time:Tue Jan 01 2019 12:09:27 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>HDFS NameNode内存全景 · PROSS</title><meta name="description" content="HDFS NameNode内存全景 - RukiapR0ss"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://pross.space/atom.xml" title="PROSS"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/prosscode" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">HDFS NameNode内存全景</h1><div class="post-info">May 7, 2018</div><div class="post-content"><blockquote><p>在HDFS系统架构中，NameNode管理着整个文件系统的元数据，维护整个集群的机架感知信息和DataNode和Block的信息，Lease管理以及集中式缓存引入的缓存管理等等。从整个HDFS系统架构上来看，NameNode是最重要、最复杂也是最容易出现问题的地方。</p></blockquote><a id="more"></a><h4 id="NameNode概述"><a href="#NameNode概述" class="headerlink" title="NameNode概述"></a>NameNode概述</h4><p>NameNode管理的HDFS文件系统的元数据分为两个层次：NameSpace管理层，负责管理文件系统中的树状目录结构以及文件与数据块之间的映射关系；块管理层，负责管理文件系统中文件的物理块与实际存储位置的映射关系（BlockMap）。</p><p>NameSpace管理的元数据除内存常驻外，也会周期Flush到持久化设备fsimage文件上（core-site.xml中配置<code>hadoop.tmp.dir</code>目录下的dfs/name/current中）；BlockMap元数据只存在于内存中；当NameNode发生重启，首先从持久化设备中读取fsimage，构建NameSpace的元数据信息，之后根据DataNode的汇报信息重新构造BlockMap，这两部分数据是占据NamNode大部分JVM Heap空间。</p><h4 id="NameNode内存结构"><a href="#NameNode内存结构" class="headerlink" title="NameNode内存结构"></a>NameNode内存结构</h4><p><img src="/archives/2018/05/07/namenode.png" alt="namenode"></p><p>NameNode常驻内存主要被NameSpace和BlockManager使用，二者使用占比分别接近50%。其它部分内存开销较小且相对固定，与NameSpace和BlockManager相比基本可以忽略。</p><h4 id="NameNode内存分析"><a href="#NameNode内存分析" class="headerlink" title="NameNode内存分析"></a>NameNode内存分析</h4><h5 id="NameSpace"><a href="#NameSpace" class="headerlink" title="NameSpace"></a>NameSpace</h5><p><img src="/archives/2018/05/07/namespace.png" alt="namespace"></p><p>HDFS文件系统的目录结构也是按照树状结构维护，NameSpace保存了目录树以及每个目录/文件节点的属性。在整个NameSpace目录树中存在两种不同类型的INode数据结构：<code>INodeDirectory</code>和<code>INodeFile</code>。其中INodeDirectory表示的是目录树中的目录，INodeFile表示的是目录树中的文件。<br><img src="/archives/2018/05/07/inode.png" alt="inode"></p><p>INodeDirectory和INodeFile均继承自INode，所以具备大部分相同的公共信息INodeWithAddititionalFields，除常用基础属性外，其中还提供了扩展属性features（如Quota，Snapshot等），如果以后出现新属性也可以通过feature扩展。不同的是，INodeFile特有的标识副本数和数据块大小组合的<code>header</code>（2.61之后新增了标识存储策略ID的信息）以及该文件包含的有序Block的数组；INodeDirectory特有的是列表<code>children</code>，children默认是大小为5的ArrayList类型，按照子节点name有序存储，在插入时会损失一部分写入的性能，但是可以方便后续快速二分查找提高读的性能，对于一般的存储系统，读操作比写操作占比要高。</p><h5 id="BlockManager"><a href="#BlockManager" class="headerlink" title="BlockManager"></a>BlockManager</h5><p>NameNode概述中介绍的负责管理文件系统中文件的物理块与实际存储位置的映射关系（BlockMap）就是由BlockManager来统一管理。NameSpace和BlockMap之间通过前面提到的INodeFile有序Blocks数组关联到一起。<br><img src="/archives/2018/05/07/blockinfo.png" alt="blockinfo"></p><p>每一个INodeFile都会包含数量不等的Block，具体数量由文件大小及每一个Block的大小比值决定，这些Block按照所在的文件的先后顺序组成BlockInfo数组，BlockInfo维护的是Block的元数据，数据本身是由DataNode管理，所以BlockInfo需要包含实际数据且由DataNode管理的信息是名为triplets的Object数组，大小为3*replicas（replicas是Block副本数量，默认为3），从图中可以知道，BlockInfo包含了哪些Block，这些Block分别存储在哪些DataNode上。</p><p>如何快速的通过BlockId快速定位到Block，这里还需要BlocksMap。</p><p>BlocksMap底层通过LightWeightGSet实现，本质是一个链式解决冲突的Hash表。事实上，BlocksMap里所有的BlockInfo就是INodeFile中对应BlockInfo的引用，通过Block查找对应BlockInfo时，也是先对Block计算HashCode，根据结果快速定位到对应的BlockInfo信息。</p><p><img src="/archives/2018/05/07/blocksMap.png" alt="blocksMap"></p><p>这里还涉及到几个核心的数据结构：excessReplicateMap（多余的副本存放） ，neededReplications（需要补充Block的副本存放处，是一个优先级队列，缺少副本数越多的Block会优先处理），invalidateBlocks（删除的副本存放处） ，corruptReplicas（某些Block不可用暂存处）等。</p><p>相比Namespace，BlockManager管理的数据要复杂的多。</p><h5 id="NetworkTopology"><a href="#NetworkTopology" class="headerlink" title="NetworkTopology"></a>NetworkTopology</h5><p>Hadoop在设计考虑到数据的安全和高效，默认存放三份副本。存储策略是本地一份，同机架内其他某一个节点上一份，不同机架的某一节点上一份，这样如果本地数据损坏了，节点可以从同一机架内的相邻节点拿到数据，速度肯定比从跨机架节点上拿到的数据要快；为了降低整体的带宽消耗和读取延时时间，HDFS会尽快让读取程序读取离它最近的副本。那么Hadoop确定任意两个节点是位于同一机架还是不同的机架呢？这就需要机架拓扑NetworkTopology，也叫作机架感知。<br>默认情况下，NameNode启动时日志信息是这样的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2018-05-09 19:27:26,423 INFO org.apache.hadoop.net.NetworkTopology: Adding a new node:  /default-rack/ 192.168.123.102:50010</div></pre></td></tr></table></figure><p>每个IP对应的机架ID都是/default-rack，说明Hadoop的机架感知没有被启用。<br><strong>配置机架感知</strong><br>配置机架感知也很简单，NameNode所在的节点中，在<code>core-site.xml</code>文件中配置<code>topology.script.name</code>，value通常是一个shell脚本，该脚本接受一个参数，输出一个值。接受的参数通常为某台DataNode的IP地址，而输出的值通常为该IP地址对应的DataNode所在的rack。<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span>  </div><div class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>topology.script.file.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </div><div class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/hadoop/apps/hadoop-2.6.5/etc/hadoop/topology.sh<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div></pre></td></tr></table></figure><p></p><p><code>topology.sh</code><br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash  </div><div class="line">HADOOP_CONF=/home/bigdata/apps/hadoop/etc/hadoop  </div><div class="line">while [ $# -gt 0 ] ; do  </div><div class="line">  nodeArg=$1  </div><div class="line">  exec&lt;$&#123;HADOOP_CONF&#125;/topology.data</div><div class="line">  result=""  </div><div class="line">  while read line ; do  </div><div class="line">    ar=( $line )  </div><div class="line">    if [ "$&#123;ar[0]&#125;" = "$nodeArg" ]||[ "$&#123;ar[1]&#125;" = "$nodeArg" ]; then  </div><div class="line">      result="$&#123;ar[2]&#125;"  </div><div class="line">    fi  </div><div class="line">  done  </div><div class="line">  shift  </div><div class="line">  if [ -z "$result" ] ; then  </div><div class="line">    echo -n "/default-rack"  </div><div class="line">  else  </div><div class="line">    echo -n "$result"  </div><div class="line">  fi  </div><div class="line">  done</div></pre></td></tr></table></figure><p></p><p><code>topology.data</code>格式为：节点（IP或主机名） /交换机xx/机架xx<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">192.168.123.102 hadoop02 /switch/rack2</div><div class="line">...</div></pre></td></tr></table></figure><p></p><p>配置后，NameNode启动时日志信息是这样的：<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2018-05-09 19:27:26,423 INFO org.apache.hadoop.net.NetworkTopology: Adding a new node:  /switch/rack2/ 192.168.123.102:50010</div></pre></td></tr></table></figure><p></p><p>说明Hadoop的机架感知已经被启用了。查看Hadoop机架信息的命令<code>hadoop dfsadmin -printTopology</code></p><h5 id="LeaseManager"><a href="#LeaseManager" class="headerlink" title="LeaseManager"></a>LeaseManager</h5><p>Lease 机制是重要的分布式协议，广泛应用于各种实际的分布式系统中。HDFS支持Write-Once-Read-Many，对文件写操作的互斥同步靠Lease实现。<br>Lease实际上是时间约束锁，其主要特点是排他性。客户端写文件时需要先申请一个Lease，一旦有客户端持有了某个文件的Lease，其它客户端就不可能再申请到该文件的Lease，这就保证了同一时刻对一个文件的写操作只能发生在一个客户端。<br>NameNode的LeaseManager是Lease机制的核心，维护了文件与Lease、客户端与Lease的对应关系，这类信息会随写数据的变化实时发生对应改变。</p><blockquote><p>本文是根据<a href="https://tech.meituan.com/namenode.html?_blank" target="_blank" rel="external">美团点评技术团队中《HDFS NameNode内存全景》</a>整理总结</p></blockquote></div></article></div></main><footer><div class="paginator"><a href="/archives/2018/05/15/" class="prev">PREV</a><a href="/archives/2018/04/25/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname="pross-space",disqus_identifier="archives/2018/05/07/",disqus_title="HDFS NameNode内存全景",disqus_url="https://pross.space/archives/2018/05/07/";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><script id="dsq-count-scr" src="//pross-space.disqus.com/count.js" async></script><div class="copyright"><p>© 2017 - 2019 <a href="https://pross.space">RukiapR0ss</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html><!-- rebuild by neat -->