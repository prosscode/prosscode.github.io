<!-- build time:Sat Sep 01 2018 00:01:57 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>Spark的运行模式 · PROSS</title><meta name="description" content="Spark的运行模式 - RukiapR0ss"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://prosscode.github.io/atom.xml" title="PROSS"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/prosscode" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Spark的运行模式</h1><div class="post-info">May 15, 2018</div><div class="post-content"><p>Spark是新一代基于内存的计算框架，是用于大规模数据处理的同意分析引擎。相比于Hadoop MapReduce计算框架，Spark将中间计算结果保留在内存中，速度提升10~100倍；同时采用弹性分布式数据集（RDD）实现迭代计算，更好的适用于数据挖掘、机器学习，极大的提升开发效率。</p><p>Spark的运行模式，它不仅支持单机模式，同时支持集群模式运行；这里具体的总结一下Spark的各种运行模式的区分。</p><h4 id="Local模式"><a href="#Local模式" class="headerlink" title="Local模式"></a>Local模式</h4><p>Local模式又称本地模式，通过Local模式运行非常简单，只需要把Spark的安装包解压后，改一些常用的配置即可使用，而不用启动Spark的Master、Worker进程（只有集群的Standalone模式运行时，才需要这两个角色），也不用启动Hadoop的服务，除非你需要用到HDFS。</p><p><strong>运行实例</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">./bin/spark-submit \</div><div class="line">	--class org.apache.spark.examples.SparkPi \</div><div class="line">	--master local[2] \</div><div class="line">	lib/spark-examples-1.0.0-hadoop2.2.0.jar  \</div><div class="line">	100</div><div class="line"></div><div class="line"># 1）--master local 就可以确定是单机的local模式了，[2]意思是分配2个cores运行</div><div class="line"># 2）--lib/spark-examples-1.0.0-hadoop2.2.0.jar：jar包的路径（application-jar）</div><div class="line"># 3）--100：传递给主类的主要方法的可选参数（application-arguments）</div></pre></td></tr></table></figure><p>这里的spark-submit进程既是客户端提交任务的Client进程，又是Spark的Driver程序，还充当着Spark执行Task的Executor角色。所有的程序都运行在一个JVM中，主要用于开发时测试。</p><h4 id="本地伪集群运行模式（单机模拟集群）"><a href="#本地伪集群运行模式（单机模拟集群）" class="headerlink" title="本地伪集群运行模式（单机模拟集群）"></a>本地伪集群运行模式（单机模拟集群）</h4><p>这种模式，和Local[N]很像，不同的是它会在单机的环境下启动多个进程来模拟集群下的分布式场景，而不像Local[N]这种多个线程只能在一个进程下委曲求全的共享资源。通常也是用来验证开发出来的应用程序逻辑上有没有出现问题，或者想使用Spark计算框架而没有太多资源的情况下。</p><p><strong>运行实例</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">./bin/spark-submit \</div><div class="line">	--master local-cluster[2,3,1024]</div><div class="line">	</div><div class="line"># --master local-cluster[2,3,1024]：在本地模拟集群下使用2个Executor进程，每个进程分配3个cores和1024M的内存来运行程序</div></pre></td></tr></table></figure><p>这里的spark-submit依然充当全能角色，又是Client进程，又是Driver程序，也负责资源管理。运行该模式很简单，只需要把Spark安装包解压后，修改一些常用的配置，不用启动Spark的Master、Worker守护进程，也不用启动Hadoop的服务，除非你是需要用到HDFS。</p><h4 id="Standalone模式（集群）"><a href="#Standalone模式（集群）" class="headerlink" title="Standalone模式（集群）"></a>Standalone模式（集群）</h4><p>Standalone是集群模式，这里就需要在执行应用程序前，先启动Spark的Master和Worker守护进程，不用启动Hadoop的服务，除非你需要使用HDFS。</p><p><strong>运行实例</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">./bin/spark-submit \</div><div class="line">  --class org.apache.spark.examples.SparkPi \</div><div class="line">  --master spark://207.184.161.138:7077 \</div><div class="line">  --executor-memory 8G \</div><div class="line">  --total-executor-cores 10 \</div><div class="line">  /path/to/examples.jar \</div><div class="line">  1000</div><div class="line"></div><div class="line"># 1) --master spark://207.184.161.138:7077:采用Standalone模式运行，后面是集群地址和端口</div><div class="line"># 2) --executor-memory 20G:配置executor进程内存为8G</div><div class="line"># 3）--total-executor-cores 100：配置cores数为10个</div></pre></td></tr></table></figure><p>Master进程作为cluster manager，用来对应用程序申请的资源进行管理；spark-submit做为Client端和运行Driver程序。Standalone模式是Spark实现的资源调度框架，其主要的节点有Client节点，Master节点和Worker节点。其中Driver既可以运行在Master节点上，也可以运行在本地的Client端。</p><p>当用spark-shell交互式工具提交Spark的Job时，Driver在Master节点上运行；当使用spark-submit工具提交Job或者在Eclipse、IDEA等开发平台上使用<code>new SparkConf.setManager(&quot;spark://master:7077&quot;)</code>方式运行Spark任务时，Driver是运行在本地Client端上的。</p><p><strong>运行流程</strong></p><ul><li>SparkContext连接到Master，向Master注册并申请资源（CPU Core和Memory）</li><li>Master根据SparkContext的资源申请要求和Worker心跳周期内报告的信息决定在哪个Worker上分配资源，然后在该Worker上获取资源，然后启动StandaloneExecutorBackend</li><li>StandaloneExecutorBackend向SparkContext注册</li><li>SparkContext将Application代码发给StandaloneExecutorBackend；并且SparkContext解析Application代码，构建DAG图，提交给DAG Scheduler分解成Stage（当碰到Action操作时，就会产生Job；每个Job中含有一个或多个Stage，Stage一般在获取外部数据和shuffle之前产生），然后Stage（又称为TaskSet）提交Task Scheduler，负责将Task分配到相应的Worker，最后提交给StandaloneExecutorBackend执行</li><li>StandaloneExecutorBackend会构建Executor线程池，开始执行Task，并向SparkContext报告，直至Task完成</li><li>所有Task完成后，SparkContext向Master注销，释放资源</li></ul><h4 id="on-yarn-client模式（集群）"><a href="#on-yarn-client模式（集群）" class="headerlink" title="on yarn client模式（集群）"></a>on yarn client模式（集群）</h4><p>越来越多的场景，都是Spark跑在Hadoop集群中，所以为了做到资源能够均衡调度，会使用YARN来做为Spark的Cluster Manager，来为Spark的应用程序分配资源。</p><p><strong>运行实例</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">./bin/spark-submit \</div><div class="line">	--class org.apache.spark.examples.SparkPi \</div><div class="line">	--master yarn \</div><div class="line">	--deploy-mode client \</div><div class="line">	lib/spark-examples-1.0.0-hadoop2.2.0.jar </div><div class="line"></div><div class="line"># 1) --master yarn：采用yarn进行资源调度</div><div class="line"># 2) --deploy-mode client：client环境运行</div></pre></td></tr></table></figure><p>在执行Spark应用程序前，要启动Hadoop的各种服务，由于已经有了资源管理器，所以不需要启动Spark的Master，Worker守护进程。</p><p><strong>运行流程</strong></p><ul><li>Spark Yarn Client向Yarn的ResourceManager申请启动Application Master，同时在SparkContext初始化中创建DAG Scheduler和Task Scheduler，由于我们选择是Yarn Client模式，程序会选择启动YarnClientClusterScheduler和YarnClientSchedulerBackend</li><li>ResourceManager收到请求后，在集群中选择一个NodeManager，为该应用程序分配第一个Container，要求它在这个Container中启动应用程序的ApplicationMaster；与YarnCluster区别是在该ApplicationMaster中不运行SparkContext，只与SparkContext进行联系进行资源的分配</li><li>Client中的SparkContext初始化完成后，与ApplicationMaster建立通讯，向ResourceManager注册，根据任务信息向ResourceManager申请资源（Container）</li><li>一旦ApplicationMaster申请到资源（也就是Container）后，便于对应的NodeManager通信，要求它在获得的Container中开始向SparkContext注册并申请执行Task任务</li><li>Client中的SparkContext分配给Container的Task开始执行，并向Driver汇报运行的状态和进度，让Client随时掌握各个任务的运行状态，从而可以在任务失败时重启任务</li><li>应用程序完成后，Client的SparkContext向ResourceManager申请注销并关闭自己</li></ul><h4 id="on-yarn-cluster模式（集群）"><a href="#on-yarn-cluster模式（集群）" class="headerlink" title="on yarn cluster模式（集群）"></a>on yarn cluster模式（集群）</h4><p><strong>运行实例</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">./bin/spark-submit --class org.apache.spark.examples.SparkPi \</div><div class="line">	--master yarn \</div><div class="line">	--deploy-mode cluster \</div><div class="line">	--driver-memory 4g \</div><div class="line">	--executor-memory 2g \</div><div class="line">	--executor-cores 1 \</div><div class="line">	examples/jars/spark-examples*.jar \</div><div class="line">	10</div><div class="line"></div><div class="line"># --driver-memory 4g：集群模式下Yarn Application Master的内存大小</div></pre></td></tr></table></figure><p><strong>运行流程</strong></p><ul><li>SparkYarnClient向YARN中ResourceManager提交应用程序，包括ApplicationMaster程序、启动ApplicationMaster的命令、需要在Executor中运行的程序</li><li>ResourceManager收到请求后，在集群中选择一个NodeManager，为该应用程序分配第一个Container，要求它在这个Container中启动应用程序的ApplicationMaster，其中ApplicationMaster中进行SparkContext的初始化</li><li>ApplicationMaster向ResourceManager注册，这样用户可以直接通过ResourceManage查看应用程序的运行状态，然后它将采用轮询的方式通过RPC协议为各个任务申请资源，并监控它们的运行状态直到运行结束</li><li>一旦ApplicationMaster申请到资源（也就是Container）后，便于对应的NodeManager通信，要求它在获得的Container中开始向SparkContext注册并申请执行Task任务</li><li>SparkContext分配给Container的Task开始执行，并向Driver汇报运行的状态和进度，让Client随时掌握各个任务的运行状态，从而可以在任务失败时重启任务</li><li>应用程序运行完成后，ApplicationMaster向ResourceManager申请注销并关闭自己</li></ul><h4 id="Mesos模式"><a href="#Mesos模式" class="headerlink" title="Mesos模式"></a>Mesos模式</h4><p>Mesos是Apache下的开源分布式资源管理框架，它被称为是分布式系统的内核。Mesos最初是由加州大学伯克利分校的AMPLab开发的，后在Twitter得到广泛使用。Apache Mesos是一个通用的集群管理器，起源于 Google 的数据中心资源管理系统Borg。</p><p>Mesos模式接触较少，这里不作为展开。</p><h4 id="Kubernetes模式（K8S）"><a href="#Kubernetes模式（K8S）" class="headerlink" title="Kubernetes模式（K8S）"></a>Kubernetes模式（K8S）</h4><p>Kubernetes调度器目前是实验性的。在未来的版本中，可能会出现配置，容器图像和入口点的行为变化。 （Spark2.3.0）</p><p>Kubernetes模式接触较少，这里不作为展开。</p></div></article></div></main><footer><div class="paginator"><a href="/archives/2018/05/29/" class="prev">PREV</a><a href="/archives/2018/05/07/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 - 2018 <a href="https://prosscode.github.io">RukiapR0ss</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html><!-- rebuild by neat -->