<!DOCTYPE HTML><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="chrome=1"><title>远程过程调用 | 博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="author" content="pross"><meta name="description" content="啊，原本是写一篇Apache Thrift in HiveServer，改写JDBC连接Hive相关应用的推文，因为HiveServer是使用Thrift提供服务创建网络RPC的多种语言客户端；单独拿出来说，使用Thrift也可以轻松构建RPC服务器，是轻量级的跨语言的远程服务调用框架。说到远程过程调用，感觉又要解释很多，所以就先上个前菜，说一说远程过程调用（RPC）；并加了一份佐料：关于JDBC"><meta name="description" content="啊，原本是写一篇Apache Thrift in HiveServer，改写JDBC连接Hive相关应用的推文，因为HiveServer是使用Thrift提供服务创建网络RPC的多种语言客户端；单独拿出来说，使用Thrift也可以轻松构建RPC服务器，是轻量级的跨语言的远程服务调用框架。说到远程过程调用，感觉又要解释很多，所以就先上个前菜，说一说远程过程调用（RPC）；并加了一份佐料：关于JDBC"><meta property="og:type" content="article"><meta property="og:title" content="远程过程调用"><meta property="og:url" content="https://pross.space/blog/2019/%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8"><meta property="og:site_name" content="博客"><meta property="og:description" content="啊，原本是写一篇Apache Thrift in HiveServer，改写JDBC连接Hive相关应用的推文，因为HiveServer是使用Thrift提供服务创建网络RPC的多种语言客户端；单独拿出来说，使用Thrift也可以轻松构建RPC服务器，是轻量级的跨语言的远程服务调用框架。说到远程过程调用，感觉又要解释很多，所以就先上个前菜，说一说远程过程调用（RPC）；并加了一份佐料：关于JDBC"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://pross.space/blog/2019/Remote-Procedure-Call%5Clocal.jpg"><meta property="og:image" content="https://pross.space/blog/2019/Remote-Procedure-Call%5Crpc.jpg"><meta property="article:published_time" content="2019-08-16T16:13:44.000Z"><meta property="article:modified_time" content="2021-01-30T07:11:57.000Z"><meta property="article:author" content="pross"><meta property="article:tag" content="技术"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://pross.space/blog/2019/Remote-Procedure-Call%5Clocal.jpg"><link rel="alternate" href="/atom.xml" title="博客" type="application/atom+xml"><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="stylesheet" href="/css/style.css"><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--><meta name="generator" content="Hexo 5.4.0"></head><body><div class="wrapper"><header id="header"><div class="title"><h1><a href="/">博客</a></h1><p><a href="/"></a></p></div><nav class="nav"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archives</a></li><li><a href="/about">About</a></li><li><a href="/daysmatter">Daysmatter</a></li><li><a href="/atom.xml">RSS</a></li></ul><div class="clearfix"></div></nav><div class="clearfix"></div></header><div class="content"><article class="post"><header><div class="icon"></div><a href="/blog/2019/远程过程调用"><time datetime="2019-08-16T16:13:44.000Z">2019-08-17</time></a><h1 class="title">远程过程调用</h1></header><div class="entry"><p>啊，原本是写一篇Apache Thrift in HiveServer，改写JDBC连接Hive相关应用的推文，因为HiveServer是使用Thrift提供服务创建网络RPC的多种语言客户端；单独拿出来说，使用Thrift也可以轻松构建RPC服务器，是轻量级的跨语言的远程服务调用框架。说到远程过程调用，感觉又要解释很多，所以就先上个前菜，说一说远程过程调用（RPC）；并加了一份佐料：关于JDBC连接Hive的实现。</p><span id="more"></span><h4 id="远程过程调用（RPC）"><a href="#远程过程调用（RPC）" class="headerlink" title="远程过程调用（RPC）"></a>远程过程调用（RPC）</h4><p>照例搬了wiki的解释：</p><blockquote><p>远程过程调用是分布式计算的客户端-服务器（Client/Server）的例子，它简单而又广受欢迎。远程过程调用总是由客户端对服务器发出一个执行若干过程请求，并用客户端提供的参数。执行结果将返回给客户端。</p><p>为了允许不同的客户端均能访问服务器，许多标准化的RPC框架应运而生。其中大部分采用接口描述语言（Interface Description Language，IDL），方便跨平台的远程过程调用。</p></blockquote><p>举一个栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">()</span></span>&#123;</span><br><span class="line">       String param1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">       String param2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">       String result = appendStr(param1, param2);</span><br><span class="line">       System.out.println(<span class="string">&quot;result:&quot;</span> + result);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">appendStr</span><span class="params">(String param1,String param2)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> param1+<span class="string">&quot; &quot;</span>+param2;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这是本地函数调用代码，调用方法和被调用的方法都在一个程序内部，是属于进程内的调用。CPU在执行<code>invoke</code>方法的时候（称为<code>调用方法</code>），会去执行被调用的<code>appendStr</code>这个方法（称为<code>被调用方法</code>），执行完成后，切换回来继续执行后续的代码。对于调用方法而言，执行被调用方法时会阻塞，直到被调用方法执行完毕。画一个简单的过程调用图如下：</p><p><img src="Remote-Procedure-Call%5Clocal.jpg"></p><p>接下来看一下RPC调用（Thrift）的栗子🌰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">()</span> <span class="keyword">throws</span> TTransportException </span>&#123;</span><br><span class="line">        TCLIService.Client client = getClient(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8088</span>);</span><br><span class="line">        String param1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String param2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        String result = client.appendStr(param1, param2);</span><br><span class="line">        System.out.println(<span class="string">&quot;result:&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// get thrift client</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TCLIService.<span class="function">Client <span class="title">getClient</span><span class="params">(String host,<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> TTransportException </span>&#123;</span><br><span class="line">        <span class="comment">// host port timeout</span></span><br><span class="line">        TSocket tSocket = <span class="keyword">new</span> TSocket(host, port,<span class="number">10000</span>);</span><br><span class="line">        TTransport transport = <span class="keyword">new</span> TFramedTransport(tSocket);</span><br><span class="line">        transport.open();</span><br><span class="line">        TProtocol protocol = <span class="keyword">new</span> TBinaryProtocol(transport);</span><br><span class="line">        TCLIService.Client client = <span class="keyword">new</span> TCLIService.Client(protocol);</span><br><span class="line">        <span class="keyword">return</span>  client;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这是一个进程间的调用，调用方法和被调用方法不在一个进程，甚至不是相同的服务，或者不同的服务器。进程之间的调用需要通过网络来传输数据，调用方法在执行RPC调用时会阻塞知道调用结果返回结果菜继续执行后续代码。过程调用图如下：</p><p><img src="Remote-Procedure-Call%5Crpc.jpg"></p><p>总结：RPC是一种通过网络从远程计算机程序上请求服务的方法。</p><h4 id="延伸：Apache-Thrift在JDBC的应用"><a href="#延伸：Apache-Thrift在JDBC的应用" class="headerlink" title="延伸：Apache Thrift在JDBC的应用"></a>延伸：Apache Thrift在JDBC的应用</h4><p>一般来说，JDBC连接数据源开发的步骤：加载驱动类-&gt;创建数据库连接-&gt;创建statement-&gt;执行SQL语句-&gt;处理结果。前段时间研究的JDBC连接Hive数据源，底层也是采用Thrift（源码在：org.apache.hive.jdbc）。前面初始化的连接会得到<code>TCLIService.Iface client</code>和 <code>TSessionHandle sessionHandle</code>。具体的执行<code>execute(String sql)</code>代码如下，我分为三步：检查是否满足执行SQL的条件，初始化查询条件并异步执行SQL，等待执行得到结果。</p><p><strong>检查条件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">       <span class="comment">// statement是否被关闭，如果关闭报SQLException：Can&#x27;t execute after statement has been closed</span></span><br><span class="line">    checkConnection(<span class="string">&quot;execute&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果stmtHandle不为空，则关闭stmtHandle</span></span><br><span class="line">    closeClientOperation();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始话标志状态</span></span><br><span class="line"><span class="comment">     * 如是否已经取消执行(isCancelled)=false，sql语句查询是否关闭(isQueryClosed)=false</span></span><br><span class="line"><span class="comment">     * 是否生成查询日志(isLogBeingGenerated)=true，sql是否已经提交执行(isExecuteStatementFailed)=false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    initFlags();</span><br><span class="line">   	</span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>初始化查询条件并执行SQL</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line">		<span class="comment">// 初始话 statement request，可以维持sessionhandle，添加sql执行</span></span><br><span class="line">    TExecuteStatementReq execReq = <span class="keyword">new</span> TExecuteStatementReq(sessHandle, sql);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置异步执行</span></span><br><span class="line">    execReq.setRunAsync(<span class="keyword">true</span>);</span><br><span class="line">    execReq.setConfOverlay(sessConf);</span><br><span class="line">    <span class="comment">//获取reentrant lock，同一个时间点只能被一个线程锁持有，确保提交执行唯一</span></span><br><span class="line">    transportLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// client执行SQL</span></span><br><span class="line">      TExecuteStatementResp execResp = client.ExecuteStatement(execReq);</span><br><span class="line">      <span class="comment">// 验证是否成功提交</span></span><br><span class="line">      Utils.verifySuccessWithInfo(execResp.getStatus());</span><br><span class="line">      <span class="comment">// execResp 获取OperationHandle</span></span><br><span class="line">      stmtHandle = execResp.getOperationHandle();</span><br><span class="line">      <span class="comment">// 正常执行-&gt;改变sql是否已经提交执行的状态为false </span></span><br><span class="line">      isExecuteStatementFailed = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException eS) &#123;</span><br><span class="line">      <span class="comment">// 异常执行：改变sql是否已经提交执行的状态为true</span></span><br><span class="line">      isExecuteStatementFailed = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">throw</span> eS;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      isExecuteStatementFailed = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(ex.toString(), <span class="string">&quot;08S01&quot;</span>, ex);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 异常退出：释放锁区域代码</span></span><br><span class="line">      transportLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>等待执行得到结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line">		<span class="comment">// 正常执行 拿到状态handle</span></span><br><span class="line">    TGetOperationStatusReq statusReq = <span class="keyword">new</span> TGetOperationStatusReq(stmtHandle);</span><br><span class="line">    <span class="comment">// 操作是否完成的状态，初始化状态false</span></span><br><span class="line">    <span class="keyword">boolean</span> operationComplete = <span class="keyword">false</span>;</span><br><span class="line">    TGetOperationStatusResp statusResp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// while循环，通过操作是否完成的状态，手动维护一个阻塞队列，如果执行完成则退出</span></span><br><span class="line">    <span class="keyword">while</span> (!operationComplete) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取reentrant lock，确保执行过程状态</span></span><br><span class="line">        transportLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 拿到执行状态</span></span><br><span class="line">          statusResp = client.GetOperationStatus(statusReq);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// 释放锁</span></span><br><span class="line">          transportLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Utils.verifySuccessWithInfo(statusResp.getStatus());</span><br><span class="line">        <span class="comment">// 获取状态，做出相应的回应</span></span><br><span class="line">        <span class="keyword">if</span> (statusResp.isSetOperationState()) &#123;</span><br><span class="line">          <span class="keyword">switch</span> (statusResp.getOperationState()) &#123;</span><br><span class="line">          <span class="keyword">case</span> CLOSED_STATE:</span><br><span class="line">          <span class="comment">// 执行完成，改变状态，退出while循环</span></span><br><span class="line">          <span class="keyword">case</span> FINISHED_STATE:</span><br><span class="line">            operationComplete = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">// 执行取消</span></span><br><span class="line">          <span class="keyword">case</span> CANCELED_STATE:</span><br><span class="line">            <span class="comment">// 01000 -&gt; warning</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">&quot;Query was cancelled&quot;</span>, <span class="string">&quot;01000&quot;</span>);</span><br><span class="line">          <span class="comment">// 错误状态</span></span><br><span class="line">          <span class="keyword">case</span> ERROR_STATE:</span><br><span class="line">            <span class="comment">// Get the error details from the underlying exception</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(statusResp.getErrorMessage(),</span><br><span class="line">                statusResp.getSqlState(), statusResp.getErrorCode());</span><br><span class="line">          <span class="comment">// 未知错误状态</span></span><br><span class="line">          <span class="keyword">case</span> UKNOWN_STATE:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">&quot;Unknown query&quot;</span>, <span class="string">&quot;HY000&quot;</span>);</span><br><span class="line">          <span class="comment">// 正在初始化，正在pending，正在运行（退出switch循环），继续while循环</span></span><br><span class="line">          <span class="keyword">case</span> INITIALIZED_STATE:</span><br><span class="line">          <span class="keyword">case</span> PENDING_STATE:</span><br><span class="line">          <span class="keyword">case</span> RUNNING_STATE:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="comment">// 执行过程中异常，获取执行日志false</span></span><br><span class="line">        isLogBeingGenerated = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 执行过程中异常，获取执行日志false</span></span><br><span class="line">        isLogBeingGenerated = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(e.toString(), <span class="string">&quot;08S01&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行完成，获取执行日志false</span></span><br><span class="line">    isLogBeingGenerated = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 流程到这里，说明已经执行完成，可以拿到结果，没有结果返回false</span></span><br><span class="line">    <span class="keyword">if</span> (!stmtHandle.isHasResultSet()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有结果，获取结果，并封装成ResultSet全局变量</span></span><br><span class="line">    resultSet =  <span class="keyword">new</span> HiveQueryResultSet.Builder(<span class="keyword">this</span>).setClient(client).setSessionHandle(sessHandle)</span><br><span class="line">        .setStmtHandle(stmtHandle).setMaxRows(maxRows).setFetchSize(fetchSize)</span><br><span class="line">        .setScrollable(isScrollableResultset).setTransportLock(transportLock)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">// 有结果，返回ture</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以上就是JDBC连接Hive数据源，并执行SQL的代码。但是，如果想要一个会话窗口维持一个Session设置，如设置执行队列，设置Job Name等，采用JDBC方式是不可取的。所以我们可以将Thrift底层从JDBC剥离出来，把初始化过程中的<code>TSessionHandle sessionHandle</code>暴露，自己手动维护起来就可以了。</p><p>完。</p></div><footer><div class="tags"><a class="tags-none-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></div><div class="clearfix"></div></footer></article></div></div><footer id="footer"><div class="copyright">&copy; 2021 <a href="/">pross</a></div><div class="theme-copyright">Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a> | Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a></div><div class="clearfix"></div></footer><script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script><script src="/js/scale.fix.js"></script><script src="/js/jquery.imagesloaded.min.js"></script><script src="/js/gallery.js"></script><link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css"><script src="/fancybox/jquery.fancybox.pack.js"></script><script type="text/javascript">jQuery(".fancybox").fancybox()</script></body></html>