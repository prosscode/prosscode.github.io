<!DOCTYPE HTML><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="chrome=1"><title>几种定时调度的介绍与实现 | 博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="author" content="pross"><meta name="description" content="由需求产出的一篇文章，憋了很久。以下将会看到，使用Timer进行任务调度，用ScheduledExecutor和Calendar实现任务调度，Spring中的任务调度TaskScheduler，开源工具包Quartz的简单介绍。
使用Timer任务调度Timer是java.util.Timer提供的比较简单的调度工具，实现任务调度的核心是Timer和TimerTask。其中Timer负责在sche"><meta name="description" content="由需求产出的一篇文章，憋了很久。以下将会看到，使用Timer进行任务调度，用ScheduledExecutor和Calendar实现任务调度，Spring中的任务调度TaskScheduler，开源工具包Quartz的简单介绍。 使用Timer任务调度Timer是java.util.Timer提供的比较简单的调度工具，实现任务调度的核心是Timer和TimerTask。其中Timer负责在sche"><meta property="og:type" content="article"><meta property="og:title" content="几种定时调度的介绍与实现"><meta property="og:url" content="https://pross.space/blog/2019/introduction-and-realization-of-several-timing-scheduling/index.html"><meta property="og:site_name" content="博客"><meta property="og:description" content="由需求产出的一篇文章，憋了很久。以下将会看到，使用Timer进行任务调度，用ScheduledExecutor和Calendar实现任务调度，Spring中的任务调度TaskScheduler，开源工具包Quartz的简单介绍。 使用Timer任务调度Timer是java.util.Timer提供的比较简单的调度工具，实现任务调度的核心是Timer和TimerTask。其中Timer负责在sche"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://pross.space/blog/2019/introduction-and-realization-of-several-timing-scheduling/timer.jpg"><meta property="article:published_time" content="2019-01-01T04:01:53.000Z"><meta property="article:modified_time" content="2021-12-05T02:43:51.189Z"><meta property="article:author" content="pross"><meta property="article:tag" content="技术"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://pross.space/blog/2019/introduction-and-realization-of-several-timing-scheduling/timer.jpg"><link rel="alternate" href="/atom.xml" title="博客" type="application/atom+xml"><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="stylesheet" href="/css/style.css"><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--><meta name="generator" content="Hexo 5.4.0"></head><body><div class="wrapper"><header id="header"><div class="title"><h1><a href="/">博客</a></h1><p><a href="/"></a></p></div><nav class="nav"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archives</a></li><li><a href="/about">About</a></li><li><a href="/daysmatter">Daysmatter</a></li><li><a href="/atom.xml">RSS</a></li></ul><div class="clearfix"></div></nav><div class="clearfix"></div></header><div class="content"><article class="post"><header><div class="icon"></div><a href="/blog/2019/introduction-and-realization-of-several-timing-scheduling/"><time datetime="2019-01-01T04:01:53.000Z">2019-01-01</time></a><h1 class="title">几种定时调度的介绍与实现</h1></header><div class="entry"><p>由需求产出的一篇文章，憋了很久。以下将会看到，使用Timer进行任务调度，用ScheduledExecutor和Calendar实现任务调度，Spring中的任务调度TaskScheduler，开源工具包Quartz的简单介绍。</p><h4 id="使用Timer任务调度"><a href="#使用Timer任务调度" class="headerlink" title="使用Timer任务调度"></a>使用Timer任务调度</h4><p>Timer是<code>java.util.Timer</code>提供的比较简单的调度工具，实现任务调度的核心是Timer和TimerTask。其中Timer负责在<code>schedule</code>方法中设定TimerTask任务，以及任务执行的起始时间<code>delay</code>和间隔执行的时间<code>period</code>；TimerTask负责创建需要调度的任务，开发者需要实现<code>run</code>方法，然后将其丢给Timer去执行即可。</p><span id="more"></span><p>下面这个例子，用不同的方法实现了两个任务调度，其中一个任务达到条件后使用<code>cancel</code>方法终止了调度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span>: timer调度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:彭爽pross</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2018/12/28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerDemo</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String taskName=<span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="comment">//构造方法</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">TimerDemo</span><span class="params">(String taskName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.taskName=taskName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;TimerTask &quot;</span>+taskName+<span class="string">&quot;,&quot;</span>+<span class="keyword">new</span> Date());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">		<span class="keyword">long</span> delay1 = <span class="number">1</span> * <span class="number">1000</span>;</span><br><span class="line">		<span class="keyword">long</span> period1 = <span class="number">1000</span>;</span><br><span class="line">		timer.schedule(<span class="keyword">new</span> TimerDemo(<span class="string">&quot;task 1&quot;</span>),delay1,period1);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">long</span> delay2 = <span class="number">2</span> * <span class="number">1000</span>;</span><br><span class="line">		<span class="keyword">long</span> period2 = <span class="number">1000</span>;</span><br><span class="line">		timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">			String taskName = <span class="string">&quot;task 2&quot;</span>;</span><br><span class="line">			<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				i++;</span><br><span class="line">				System.out.println(<span class="string">&quot;TimerTask &quot;</span>+taskName+<span class="string">&quot;,&quot;</span>+<span class="keyword">new</span> Date());</span><br><span class="line">				<span class="keyword">if</span>(i&gt;<span class="number">2</span>)&#123;</span><br><span class="line">					cancel();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,delay2,period2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制变量<code>i</code>大于等于2后，任务调度被终止，只剩下一个任务。输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TimerTask task <span class="number">1</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">25</span> CST <span class="number">2018</span></span><br><span class="line">TimerTask task <span class="number">2</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">26</span> CST <span class="number">2018</span></span><br><span class="line">TimerTask task <span class="number">1</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">26</span> CST <span class="number">2018</span></span><br><span class="line">TimerTask task <span class="number">2</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">27</span> CST <span class="number">2018</span></span><br><span class="line">TimerTask task <span class="number">1</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">27</span> CST <span class="number">2018</span></span><br><span class="line">TimerTask task <span class="number">2</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">28</span> CST <span class="number">2018</span></span><br><span class="line">TimerTask task <span class="number">1</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">28</span> CST <span class="number">2018</span></span><br><span class="line">TimerTask task <span class="number">1</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">29</span> CST <span class="number">2018</span></span><br><span class="line">TimerTask task <span class="number">1</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">30</span> CST <span class="number">2018</span></span><br><span class="line">TimerTask task <span class="number">1</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">31</span> CST <span class="number">2018</span></span><br><span class="line">TimerTask task <span class="number">1</span>,Sat Dec <span class="number">29</span> <span class="number">15</span>:<span class="number">03</span>:<span class="number">32</span> CST <span class="number">2018</span></span><br></pre></td></tr></table></figure><p>如果调整调度周期，会发现所有的任务都是同一个线程来调度的，多个任务是串行执行，前一个任务的延迟或异常都将会影响到之后的任务。下图是Timer类的结构。</p><p><img src="./timer.jpg"></p><p>我们从执行开始追溯源码，先进入<code>schedule</code>方法，发现最终是调用的<code>sched</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(TimerTask task, <span class="keyword">long</span> delay, <span class="keyword">long</span> period)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delay &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Negative delay.&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Non-positive period.&quot;</span>);</span><br><span class="line">    	<span class="comment">// schedule方法，最终调用sched()</span></span><br><span class="line">        sched(task, System.currentTimeMillis()+delay, -period);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里我们发现了<code>queue</code>和<code>thread</code>的踪影，给<code>queue</code>加上控制线程同步<code>synchronized</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TaskQueue queue = <span class="keyword">new</span> TaskQueue();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TimerThread thread = <span class="keyword">new</span> TimerThread(queue);</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sched</span><span class="params">(TimerTask task, <span class="keyword">long</span> time, <span class="keyword">long</span> period)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (time &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal execution time.&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>))</span><br><span class="line">            period &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(queue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!thread.newTasksMayBeScheduled)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Timer already cancelled.&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span>(task.lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (task.state != TimerTask.VIRGIN)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        <span class="string">&quot;Task already scheduled or cancelled&quot;</span>);</span><br><span class="line">                task.nextExecutionTime = time;</span><br><span class="line">                task.period = period;</span><br><span class="line">                task.state = TimerTask.SCHEDULED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 满足执行条件，加入queue</span></span><br><span class="line">            queue.add(task);</span><br><span class="line">            <span class="keyword">if</span> (queue.getMin() == task)</span><br><span class="line">                queue.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们继续看TaskThread的执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行mainLoop()开始调度任务</span></span><br><span class="line">            mainLoop();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(queue) &#123;</span><br><span class="line">               <span class="comment">/** </span></span><br><span class="line"><span class="comment">                * 当newTasksMayBeScheduled是false时</span></span><br><span class="line"><span class="comment">                * 在上面sched方法中会抛出IllegalStateException异常</span></span><br><span class="line"><span class="comment">                * 所以只能同一时间执行一个任务</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                newTasksMayBeScheduled = <span class="keyword">false</span>;</span><br><span class="line">                queue.clear(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>mainLoop</code>方法就不展开，这里展示核心代码段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(task.lock) &#123;</span><br><span class="line">    <span class="comment">// 查看任务状态</span></span><br><span class="line">    <span class="keyword">if</span> (task.state == TimerTask.CANCELLED) &#123;</span><br><span class="line">        queue.removeMin();</span><br><span class="line">        <span class="keyword">continue</span>;  <span class="comment">// No action required, poll queue again</span></span><br><span class="line">    &#125;</span><br><span class="line">    currentTime = System.currentTimeMillis();</span><br><span class="line">    executionTime = task.nextExecutionTime;</span><br><span class="line">    <span class="comment">// 比较时间</span></span><br><span class="line">    <span class="keyword">if</span> (taskFired = (executionTime&lt;=currentTime)) &#123;</span><br><span class="line">        <span class="comment">// 调度周期为0，removemin</span></span><br><span class="line">        <span class="keyword">if</span> (task.period == <span class="number">0</span>) &#123; <span class="comment">// Non-repeating, remove</span></span><br><span class="line">            queue.removeMin();</span><br><span class="line">            task.state = TimerTask.EXECUTED;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// Repeating task, reschedule</span></span><br><span class="line">            queue.rescheduleMin(</span><br><span class="line">                task.period&lt;<span class="number">0</span> ? currentTime - task.period : executionTime + task.period);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后总结下，Timer 的设计核心是一个<code>TaskQueue</code>和一个<code>TaskThread</code>。Timer 将接收到的任务丢到自己的<code>TaskQueue</code>中，TaskQueue按照Task的最初执行时间进行排序。TimerThread在创建Timer时会启动成为一个守护线程。这个线程会轮询所有任务，找到一个最近要执行的任务，然后休眠，当到达最近要执行任务的开始时间点，TimerThread被唤醒并执行该任务。之后TimerThread更新最近一个要执行的任务，继续休眠。</p><p>Timer的优点在于简单易用，缺点除了单线程调度问题，还有使用的场景比较单一。比如，设置每星期二的16:38:10执行任务，Timer就不是太适用。</p><h4 id="用ScheduledExecutor和Calendar实现任务调度"><a href="#用ScheduledExecutor和Calendar实现任务调度" class="headerlink" title="用ScheduledExecutor和Calendar实现任务调度"></a>用ScheduledExecutor和Calendar实现任务调度</h4><p>这是两个东西组合使用，所以先简单介绍下<code>ScheduledExecutor</code></p><h5 id="ScheduledExecutor"><a href="#ScheduledExecutor" class="headerlink" title="ScheduledExecutor"></a>ScheduledExecutor</h5><p>与Timer比较，优化了任务执行方式，采用线程池并行执行，说到线程池，上篇文章有过一点介绍了。这里直接上代码例子，介绍看注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span>: ScheduledExecutor 任务调度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:彭爽pross</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2018/12/28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledExecutorDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;task 1&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 初始化线程池</span></span><br><span class="line">		ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">		<span class="comment">// task 1 ，scheduleAtFixedRate方法，需要指明时间单位，实现的是runnable</span></span><br><span class="line">        <span class="comment">// 所以每一个任务都是单独的一个线程</span></span><br><span class="line">		service.scheduleAtFixedRate(<span class="keyword">new</span> ScheduledExecutorDemo(),<span class="number">1000</span>,<span class="number">1000</span>, TimeUnit.SECONDS);</span><br><span class="line">		<span class="comment">// task 2</span></span><br><span class="line">		service.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;task 2&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,<span class="number">1000</span>,<span class="number">1000</span>,TimeUnit.SECONDS);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于日历类<code>Calendar</code>就不做详细讲解，我们来看看怎么Calendar+ScheduledExecutor解决较为复杂的调度。</p><h5 id="实现每周五12点调度任务"><a href="#实现每周五12点调度任务" class="headerlink" title="实现每周五12点调度任务"></a>实现每周五12点调度任务</h5><p>代码一现，其义自见。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:彭爽pross</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2018/12/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledExecuteCalendar</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 初始化线程池</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 计算从当前时间currentDate开始，</span></span><br><span class="line"><span class="comment">	 * 满足条件dayOfWeek, hourOfDay,minuteOfHour, secondOfMinite的最近时间</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Calendar <span class="title">getEarliestDate</span><span class="params">(Calendar currentDate, <span class="keyword">int</span> dayOfWeek,</span></span></span><br><span class="line"><span class="params"><span class="function">	                                <span class="keyword">int</span> hourOfDay, <span class="keyword">int</span> minuteOfHour, <span class="keyword">int</span> secondOfMinite)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//计算当前时间的WEEK_OF_YEAR,DAY_OF_WEEK, HOUR_OF_DAY, MINUTE,SECOND等各个字段值</span></span><br><span class="line">		<span class="keyword">int</span> currentWeekOfYear = currentDate.get(Calendar.WEEK_OF_YEAR);</span><br><span class="line">		<span class="keyword">int</span> currentDayOfWeek = currentDate.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">		<span class="keyword">int</span> currentHour = currentDate.get(Calendar.HOUR_OF_DAY);</span><br><span class="line">		<span class="keyword">int</span> currentMinute = currentDate.get(Calendar.MINUTE);</span><br><span class="line">		<span class="keyword">int</span> currentSecond = currentDate.get(Calendar.SECOND);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//如果输入条件中的dayOfWeek小于当前日期的dayOfWeek,则WEEK_OF_YEAR需要推迟一周</span></span><br><span class="line">		<span class="keyword">boolean</span> weekLater = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (dayOfWeek &lt; currentDayOfWeek) &#123;</span><br><span class="line">			weekLater = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//当输入条件与当前日期的dayOfWeek相等时，输入条件中的 hourOfDay小于当前日期的 currentHour，则WEEK_OF_YEAR需要推迟一周</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (dayOfWeek == currentDayOfWeek) &#123;</span><br><span class="line">			<span class="keyword">if</span> (hourOfDay &lt; currentHour) &#123;</span><br><span class="line">				weekLater = <span class="keyword">true</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (hourOfDay == currentHour) &#123;</span><br><span class="line">				<span class="comment">//当输入条件与当前日期的dayOfWeek, hourOfDay相等时，输入条件中的minuteOfHour小于当前日期currentMinute，则WEEK_OF_YEAR需要推迟一周</span></span><br><span class="line">				<span class="keyword">if</span> (minuteOfHour &lt; currentMinute) &#123;</span><br><span class="line">					weekLater = <span class="keyword">true</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (minuteOfHour == currentSecond) &#123;</span><br><span class="line">					<span class="comment">//当输入条件与当前日期的dayOfWeek, hourOfDay，minuteOfHour相等时，如果输入条件中的secondOfMinite小于当前日期的currentSecond，则WEEK_OF_YEAR需要推迟一周</span></span><br><span class="line">					<span class="keyword">if</span> (secondOfMinite &lt; currentSecond) &#123;</span><br><span class="line">						weekLater = <span class="keyword">true</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (weekLater) &#123;</span><br><span class="line">			<span class="comment">//设置当前日期中的WEEK_OF_YEAR为当前周推迟一周</span></span><br><span class="line">			currentDate.set(Calendar.WEEK_OF_YEAR, currentWeekOfYear + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 设置当前日期中的DAY_OF_WEEK,HOUR_OF_DAY,MINUTE,SECOND为输入条件中的值。</span></span><br><span class="line">		currentDate.set(Calendar.DAY_OF_WEEK, dayOfWeek);</span><br><span class="line">		currentDate.set(Calendar.HOUR_OF_DAY, hourOfDay);</span><br><span class="line">		currentDate.set(Calendar.MINUTE, minuteOfHour);</span><br><span class="line">		currentDate.set(Calendar.SECOND, secondOfMinite);</span><br><span class="line">		<span class="keyword">return</span> currentDate;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ScheduledExecuteCalendar test = <span class="keyword">new</span> ScheduledExecuteCalendar();</span><br><span class="line">		<span class="comment">// 获取当前时间</span></span><br><span class="line">		Calendar currentDate = Calendar.getInstance();</span><br><span class="line">		<span class="keyword">long</span> currentDateLong = currentDate.getTime().getTime();</span><br><span class="line">		System.out.println(<span class="string">&quot;当前日期： &quot;</span> + currentDate.getTime().toString());</span><br><span class="line">		<span class="comment">// 计算满足条件的最近一次执行时间</span></span><br><span class="line">		Calendar earliestDate = test.getEarliestDate(currentDate, <span class="number">6</span>, <span class="number">12</span>, <span class="number">00</span>, <span class="number">00</span>);</span><br><span class="line">		<span class="comment">//计算第一次执行延迟时间</span></span><br><span class="line">		<span class="keyword">long</span> earliestDateLong = earliestDate.getTime().getTime();</span><br><span class="line">		<span class="keyword">long</span> delay = earliestDateLong - currentDateLong;</span><br><span class="line">		System.out.println(<span class="string">&quot;下一次执行时间：&quot;</span>+earliestDate.getTime().toString());</span><br><span class="line">		<span class="comment">//计算执行周期为一星期</span></span><br><span class="line">		<span class="keyword">long</span> period = <span class="number">7</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;等待执行...&quot;</span>);</span><br><span class="line">		service.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;Task ScheduledExecute&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, delay, period, TimeUnit.MILLISECONDS); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Spring中的任务调度TaskScheduler"><a href="#Spring中的任务调度TaskScheduler" class="headerlink" title="Spring中的任务调度TaskScheduler"></a>Spring中的任务调度TaskScheduler</h4><p>TaskScheduler用于对Runnable的任务进行调度，其中包含多种实现，多数对任务进行调度的实现是<code>ThreadPoolTaskScheduler</code>；另外需要用到<code>Trigger</code>接口计算任务的下次执行时间；我们先看下Trigger接口的实现。</p><h5 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h5><p>Trigger接口定义如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Trigger</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine the next execution time according to the given trigger context.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> triggerContext context object encapsulating last execution times</span></span><br><span class="line"><span class="comment">	 * and last completion time</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the next execution time as defined by the trigger,</span></span><br><span class="line"><span class="comment">	 * or &#123;<span class="doctag">@code</span> null&#125; if the trigger won&#x27;t fire anymore</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">Date <span class="title">nextExecutionTime</span><span class="params">(TriggerContext triggerContext)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中提供了一个接口：<code>nextExecutionTime</code>来获取下次执行时间，接受的参数为TirggerContxt对象，这个参数对象能获取上次原本的计划时间 / 实际的执行时间 / 实际的完成时间，你问我是怎么知道？点进去看源码呀！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TriggerContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the last &lt;i&gt;scheduled&lt;/i&gt; execution time of the task,</span></span><br><span class="line"><span class="comment">	 * or &#123;<span class="doctag">@code</span> null&#125; if not scheduled before.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">Date <span class="title">lastScheduledExecutionTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the last &lt;i&gt;actual&lt;/i&gt; execution time of the task,</span></span><br><span class="line"><span class="comment">	 * or &#123;<span class="doctag">@code</span> null&#125; if not scheduled before.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">Date <span class="title">lastActualExecutionTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the last completion time of the task,</span></span><br><span class="line"><span class="comment">	 * or &#123;<span class="doctag">@code</span> null&#125; if not scheduled before.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">Date <span class="title">lastCompletionTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续返回来，来看看有哪些实现类继承Trigger接口（IDEA中快捷键，<code>option + command +B</code> / <code>ctrl + alt + B</code> ）；第一个是<code>CronTrigger</code>，通过<code>Crob</code>表达式来生成的调度计划，还可以选择是否加上时区。</p><p>举例：工作日的9-17点之间，每隔30分钟执行一次；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> CronTrigger(<span class="string">&quot;0 0/30 9-17 * * MON-FRI&quot;</span>)</span><br></pre></td></tr></table></figure><p>第二个实现类是<code>PeriodicTrigger</code>，也用于定期执行，有两种模式可以选择：<code>setFixedRate</code>，boolean类型，默认是false。和 <code>setInitialDelay</code>，long类型，表示启动任务后延迟多长时间开始执行第一次任务。最后就是构造方法，参数<code>period</code>，long类型，表示间隔时长；参数<code>timeUnit</code>，TimeUnit类型，指定时长单位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Specify whether the periodic interval should be measured between the</span></span><br><span class="line"><span class="comment"> * scheduled start times rather than between actual completion times.</span></span><br><span class="line"><span class="comment"> * The latter, &quot;fixed delay&quot; behavior, is the default.</span></span><br><span class="line"><span class="comment"> * 简明总结为：两次任务开始时间的间隔为指定的时长(period)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFixedRate</span><span class="params">(<span class="keyword">boolean</span> fixedRate)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.fixedRate = fixedRate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Specify the delay for the initial execution. It will be evaluated in</span></span><br><span class="line"><span class="comment"> * terms of this trigger&#x27;s &#123;<span class="doctag">@link</span> TimeUnit&#125;. If no time unit was explicitly</span></span><br><span class="line"><span class="comment"> * provided upon instantiation, the default is milliseconds.</span></span><br><span class="line"><span class="comment"> * 简明总结为：设置启动调度后，设置执行第一次任务的延迟时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInitialDelay</span><span class="params">(<span class="keyword">long</span> initialDelay)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.initialDelay = <span class="keyword">this</span>.timeUnit.toMillis(initialDelay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>TaskScheduler</strong></p><p>TaskScheduler接口的实现类有ThreadPoolTaskScheduler，其中还有ConcurrentTaskScheduler，DefaultManagedTaskScheduler，TimerManagerTaskScheduler，这里重要说下默认的实现类ThreadPoolTaskScheduler。</p><p>在大多数场景下都使用它来进行任务调度，除了实现TaskScheduler接口外，还包含了一些对ThreadPoolTaskScheduler进行操作的接口：<code>AsyncListenableTaskExecutor</code>和<code>SchedulingTaskExecutor</code>。其常用的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置线程池大小，默认为poolsize=1。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPoolSize</span><span class="params">(<span class="keyword">int</span> poolSize)</span> </span>&#123;</span><br><span class="line">		Assert.isTrue(poolSize &gt; <span class="number">0</span>, <span class="string">&quot;&#x27;poolSize&#x27; must be 1 or higher&quot;</span>);</span><br><span class="line">		<span class="keyword">this</span>.poolSize = poolSize;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.scheduledExecutor <span class="keyword">instanceof</span> ScheduledThreadPoolExecutor) &#123;</span><br><span class="line">			((ScheduledThreadPoolExecutor) <span class="keyword">this</span>.scheduledExecutor).setCorePoolSize(poolSize);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异常处理起</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setErrorHandler</span><span class="params">(ErrorHandler errorHandler)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.errorHandler = errorHandler;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前活动的线程数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getActiveCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.scheduledExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// Not initialized yet: assume no active threads.</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> getScheduledThreadPoolExecutor().getActiveCount();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交执行任务，需继承必须重写的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">		Executor executor = getScheduledExecutor();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			executor.execute(errorHandlingTask(task, <span class="keyword">false</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> TaskRejectedException(<span class="string">&quot;Executor [&quot;</span> + executor + <span class="string">&quot;] did not accept task: &quot;</span> + task, ex);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交执行一次的任务，并且返回一个Future对象供判断任务状态使用</span></span><br><span class="line"><span class="comment">// submit/submitListenable</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">		ExecutorService executor = getScheduledExecutor();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> executor.submit(errorHandlingTask(task, <span class="keyword">false</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> TaskRejectedException(<span class="string">&quot;Executor [&quot;</span> + executor + <span class="string">&quot;] did not accept task: &quot;</span> + task, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p>Spring中提供<code>Scheduled</code>注解来实现快捷的任务调度，需要注意的是必须使用<code>@EnableScheduling</code>注解启用对<code>@Scheduled</code>注解的支持，@EnableScheduling必须使用在项目中某一个被<code>@Configuration</code>注解的类上，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Scheduled注解用在方法下，用户表示这个方法将会被调度，所注解的方法返回类型最好是<code>void</code>类型，否则它的返回值将不会被TaskScheduler所使用。同时，如果需要参数对象，需要通过依赖注入的方式引用，其中包含：</p><ul><li>cron：使用cron语法来指定调度计划</li><li>zone：指定时区，默认为本时区</li><li>fixedDelay：指定fixedDelay的值，默认单位是毫秒</li><li>fixedRate：指定上一次任务开始时间到下一次任务开始时间的间隔时间，单位默认是毫秒</li><li>initialDelay：设置初始延迟时间</li></ul><p>其中cron / fixedDelay / fixedRate三个属性必须且只能出现一个，下面举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ScheduleService.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 4000)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSchedule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;TestSchedule begins to execute!&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;TestSchedule has been interrupted!&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">&quot;TestSchedule execution was completed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个直接在Spring Boot中使用<code>@Autowired</code>注解的方式，直接实现threadPoolTaskScheduler，实现动态的添加、修改、删除定时任务，也是实现需求考虑的方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledFuture;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.support.CronTrigger;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:彭爽pross</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2018/12/28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicTaskController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskScheduler threadPoolTaskScheduler;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在ScheduledFuture中cancel可以停止定时任务。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ScheduledFuture&lt;?&gt; future;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ThreadPoolTaskScheduler：线程池任务调度类，能够开启线程池进行任务调度。</span></span><br><span class="line"><span class="comment">     * ThreadPoolTaskScheduler.schedule()方法会创建一个定时计划ScheduledFuture，在这个方法需要添加两个参数，Runnable（线程接口类） 和CronTrigger（定时任务触发器）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolTaskScheduler <span class="title">threadPoolTaskScheduler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolTaskScheduler();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动任务，每五秒钟执行一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/startTask&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">startCron</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       future = threadPoolTaskScheduler.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;execute task&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="keyword">new</span> CronTrigger(<span class="string">&quot;0/5 * * * * *&quot;</span>));</span><br><span class="line">       System.out.println(<span class="string">&quot;DynamicTaskController.startCron()&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;startTask&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启此任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/stopTask&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">stopCron</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (future != <span class="keyword">null</span>) &#123;</span><br><span class="line">           future.cancel(<span class="keyword">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;DynamicTaskController.stopCron()&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;stopTask&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 变更任务间隔，再次启动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/changeCron&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">changeCron</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 先停止，在开启</span></span><br><span class="line">       stopCron();</span><br><span class="line">       future = threadPoolTaskScheduler.schedule(<span class="keyword">new</span> MyRunnable(), <span class="keyword">new</span> CronTrigger(<span class="string">&quot;*/10 * * * * *&quot;</span>));</span><br><span class="line">       System.out.println(<span class="string">&quot;DynamicTaskController.changeCron()&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;changeCron&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单介绍开源工具包Quartz"><a href="#简单介绍开源工具包Quartz" class="headerlink" title="简单介绍开源工具包Quartz"></a>简单介绍开源工具包Quartz</h4><p>Quartz 可以满足更多更复杂的调度需求，设计的核心类包括 Scheduler，Job 以及Trigger。其中Job 负责定义需要执行的任务，Trigger 负责设置调度策略，Scheduler 将二者组装在一起，并触发任务开始执行，除了Job其它的核心类大多已经简单介绍过，下面看看Job。</p><p><strong>Job</strong></p><p>使用者只需要创建一个 Job 的继承类，实现<code>execute</code>方法。<code>JobDetail</code>负责封装 Job 以及 Job 的属性，并将其提供给 Scheduler 作为参数。每次 Scheduler 执行任务时，首先会创建一个 Job 的实例，然后再调用 execute 方法执行。Quartz 没有为 Job 设计带参数的构造函数，因此需要通过额外的 JobDataMap 来存储 Job 的属性。JobDataMap 可以存储任意数量的 Key，Value键值对。</p><p>举个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.Job;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobDetail;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionContext;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionException;</span><br><span class="line"><span class="keyword">import</span> org.quartz.Scheduler;</span><br><span class="line"><span class="keyword">import</span> org.quartz.SchedulerFactory;</span><br><span class="line"><span class="keyword">import</span> org.quartz.Trigger;</span><br><span class="line"><span class="keyword">import</span> org.quartz.helpers.TriggerUtils;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span>: 创建一个MyJob类，实现Job接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:彭爽pross</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2018/12/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJob</span> <span class="keyword">implements</span> <span class="title">Job</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scheduler scheduler = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 创建一个JobDetail实例</span></span><br><span class="line">			JobBuilder jobBuilder = JobBuilder.newJob(MyJob.class);</span><br><span class="line">			jobBuilder.withDescription(<span class="string">&quot;test read desc.&quot;</span>);</span><br><span class="line">			JobDetail jobDetail = jobBuilder.build();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 创建一个调度规则, 每3s运行一次</span></span><br><span class="line">			SimpleScheduleBuilder simpleBuilder = SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(<span class="number">3</span>).repeatForever();</span><br><span class="line">			Trigger trigger = TriggerBuilder.newTrigger().withSchedule(simpleBuilder).startNow().build();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 从工厂中获取一个调度器Scheduler</span></span><br><span class="line">			SchedulerFactory schedulerFactory = <span class="keyword">new</span> StdSchedulerFactory();</span><br><span class="line">			scheduler = schedulerFactory.getScheduler();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 注册jobDetail, trigger到调度器Scheduler</span></span><br><span class="line">			scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 开始执行Job</span></span><br><span class="line">			scheduler.start();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 出异常了, 停止执行Job</span></span><br><span class="line">				scheduler.shutdown();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (SchedulerException e2) &#123;</span><br><span class="line">				e2.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			e1.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException</span>&#123;</span><br><span class="line">		String description = jobExecutionContext.getJobDetail().getDescription();</span><br><span class="line">		System.out.println(<span class="string">&quot;定时Job开始运行: &quot;</span> + description);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Quartz还可以和Spring整合使用，需要创建一个具体的作业任务的实现类，使用JobDetailFactoryBean来管理作业任务。具体就不细致展开，这篇文章篇幅已经够长了，</p><p>几种定时调度的介绍和实现暂时就写这么多。</p><p>完。</p></div><footer><div class="tags"><a class="tags-none-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></div><div class="clearfix"></div></footer></article></div></div><footer id="footer"><div class="copyright">&copy; 2021 <a href="/">pross</a></div><div class="theme-copyright">Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a> | Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a></div><div class="clearfix"></div></footer><script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script><script src="/js/scale.fix.js"></script><script src="/js/jquery.imagesloaded.min.js"></script><script src="/js/gallery.js"></script><link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css"><script src="/fancybox/jquery.fancybox.pack.js"></script><script type="text/javascript">jQuery(".fancybox").fancybox()</script></body></html>