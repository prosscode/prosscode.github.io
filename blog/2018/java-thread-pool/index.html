<!DOCTYPE HTML><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="chrome=1"><title>Java线程池 | 博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="author" content="pross"><meta name="description" content="虽然之前学习了不少相关知识，但是只有在实践中踩坑才能印象深刻。今天看了半天的java对线程池的处理，额外兴致来，总结一份java线程池相关。"><meta name="description" content="虽然之前学习了不少相关知识，但是只有在实践中踩坑才能印象深刻。今天看了半天的java对线程池的处理，额外兴致来，总结一份java线程池相关。"><meta property="og:type" content="article"><meta property="og:title" content="Java线程池"><meta property="og:url" content="https://pross.space/blog/2018/java-thread-pool/index.html"><meta property="og:site_name" content="博客"><meta property="og:description" content="虽然之前学习了不少相关知识，但是只有在实践中踩坑才能印象深刻。今天看了半天的java对线程池的处理，额外兴致来，总结一份java线程池相关。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://pross.space/blog/2018/java-thread-pool/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%5CExecutors.jpg"><meta property="og:image" content="https://pross.space/blog/2018/java-thread-pool/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%5CThreadPool.png"><meta property="article:published_time" content="2018-12-22T15:59:18.000Z"><meta property="article:modified_time" content="2021-12-05T08:28:50.555Z"><meta property="article:author" content="pross"><meta property="article:tag" content="技术"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://pross.space/blog/2018/java-thread-pool/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%5CExecutors.jpg"><link rel="alternate" href="/atom.xml" title="博客" type="application/atom+xml"><link rel="icon" type="image/x-icon" href="/favicon.ico"><link rel="stylesheet" href="/css/style.css"><!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--><meta name="generator" content="Hexo 5.4.0"></head><body><div class="wrapper"><header id="header"><div class="title"><h1><a href="/">博客</a></h1><p><a href="/"></a></p></div><nav class="nav"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archives</a></li><li><a href="/about">About</a></li><li><a href="/daysmatter">Daysmatter</a></li><li><a href="/atom.xml">RSS</a></li></ul><div class="clearfix"></div></nav><div class="clearfix"></div></header><div class="content"><article class="post"><header><div class="icon"></div><a href="/blog/2018/java-thread-pool/"><time datetime="2018-12-22T15:59:18.000Z">2018-12-22</time></a><h1 class="title">Java线程池</h1></header><div class="entry"><p>虽然之前学习了不少相关知识，但是只有在实践中踩坑才能印象深刻。今天看了半天的java对线程池的处理，额外兴致来，总结一份java线程池相关。</p><span id="more"></span><h4 id="线程池的后果"><a href="#线程池的后果" class="headerlink" title="线程池的后果"></a>线程池的后果</h4><h5 id="Java提供的工具类-Executors"><a href="#Java提供的工具类-Executors" class="headerlink" title="Java提供的工具类-Executors"></a>Java提供的工具类-Executors</h5><p>Executors是一个Java中的工具类，提供工厂方法来创建不同类型的线程池。 提供方法如下：</p><p><img src="Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%5CExecutors.jpg"></p><p>然后阿里巴巴Java开发手册中这样提到：</p><blockquote><ol><li><p>【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><pre><code>说明:Executors 返回的线程池对象的弊端如下:
      
1）FixedThreadPool 和 SingleThreadPool: 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 
                  
2)CachedThreadPool 和 ScheduledThreadPool: 允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。 
</code></pre></li></ol></blockquote><p>第一个关键词：OOM。怎么导致OOM的呢，那就show codes，一起来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span>: Executors线程池创建，证明使用Executors会造成oom</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:彭爽pross</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2018/12/21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsDemo</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;Integer.MAX_VALUE;i++)&#123;</span><br><span class="line">			executor.execute(<span class="keyword">new</span> subThread());</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread count：&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">subThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码里刻意调整线程数量，启动时故意设置内存大小（模拟上限内存）：<code>-Xmx8m -Xms8m</code>。运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br><span class="line">	at java.util.concurrent.LinkedBlockingQueue.offer(LinkedBlockingQueue.java:<span class="number">416</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:<span class="number">1371</span>)</span><br><span class="line">	at org.pross.threadPool.ExecutorsDemo.main(ExecutorsDemo.java:<span class="number">18</span>)</span><br></pre></td></tr></table></figure><p>错误就是很明显的，OOM问题。再出现OOM之前，会一直有打印输出，一直达到内存上限为止。为什么使用Executors创建线程池就会错误，那我们就来追溯Java创建线程池造成OOM的原因。</p><h5 id="Executors为什么存在缺陷"><a href="#Executors为什么存在缺陷" class="headerlink" title="Executors为什么存在缺陷"></a>Executors为什么存在缺陷</h5><p>往上面结果看一眼，最终执行错误代码到了这一行：<code>java.util.concurrent.LinkedBlockingQueue.offer(LinkedBlockingQueue.java:416)</code>。敲黑板划一下第二个关键词：<code>LinkedBlockingQueue</code>，点进<code>newFixedThreadPool</code> 可以发现关键词的踪影：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param nThreads the number of threads in the pool</span></span><br><span class="line"><span class="comment"> * @return the newly created thread pool</span></span><br><span class="line"><span class="comment"> * @throws IllegalArgumentException if &#123;@code nThreads &lt;= 0&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就需要继续说下Java的堵塞队列。Java中的<code>BlockingQueue</code>主要的实现方式是<code>ArrayBlockingQueue</code>，<code>LinkedBlockingQueue</code>。ArrayBlockingQueue是一个用数组实现的有界的阻塞队列，必须设置容量。但是我们默认的LinkedBlockingQueue是一个用链表实现的有界阻塞队列，容量可以选择行进行设置，不设置的话，就是一个无边界的阻塞队列，最大长度为<code>Integer.MAX_VALUE</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> LinkedBlockingQueue&#125; with a capacity of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Integer#MAX_VALUE&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以就很简单的找到了问题所在，不设置LinkedBlockingQueue容量大小的话就是默认是Integer.MAX_VALUE。而最开始创建newFixedThreadPool时候，并没有可以指定的字段。所以出现OOM是正常的，阿里巴巴Java开发手册中不允许使用 Executors 去创建是正常的。 那我们想使用线程池怎么去创建呢？</p><h5 id="创建线程池的正确姿势"><a href="#创建线程池的正确姿势" class="headerlink" title="创建线程池的正确姿势"></a>创建线程池的正确姿势</h5><p>我们继续往前看newFixedThreadPool是怎么实现的那段源码，继续敲第三个关键词：<code>ThreadPoolExecutor</code>，是直接返回ThreadPoolExecutor对象，创建包含各个字段信息，其中就有LinkedBlockingQueue。那我们能不能直接调用ThreadPoolExecutor的构造函数来自己创建线程池，在创建的同时，给LinkedBlockingQueue指定容量呢？这个问答必须是Yes。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">200</span>, <span class="number">0L</span>, </span><br><span class="line">		TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">1024</span>));</span><br></pre></td></tr></table></figure><p>如上代码直接调用ThreadPoolExecutor来自己创建线程池。我们替换掉前面写的Demo中创建的方式，启动运行，结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.util.concurrent.RejectedExecutionException: Task org.pross.threadPool.subThreadPool@2e5d6d97 rejected from java.util.concurrent.ThreadPoolExecutor@238e0d81[Running, pool size = <span class="number">200</span>, active threads = <span class="number">200</span>, queued tasks = <span class="number">1024</span>, completed tasks = <span class="number">0</span>]</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:<span class="number">2063</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:<span class="number">830</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:<span class="number">1379</span>)</span><br><span class="line">	at org.pross.threadPool.ThreadPoolExecutorDemo.main(ThreadPoolExecutorDemo.java:<span class="number">18</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果还是有问题，和上次不同的是，这次是抛出的异常信息，但是异常（Exception）总比发生错误（Error）要好，敲黑板划一下第四个关键词：<code>ThreadPoolExecutor$AbortPolicy.rejectedExecution</code>。这个关键词代表的信息很简单，是因为当前线程池使用的队列是有边界队列，队列已经满了便无法继续处理新的请求，所以就会抛出rejectedExecution，所以这次打印输出只到<code>Thread count：1224</code>，1224即队列最大数加上最大线程池数之和。</p><h4 id="线程池的前因"><a href="#线程池的前因" class="headerlink" title="线程池的前因"></a>线程池的前因</h4><p>如果只看结果和使用，那么到这里就结束了。如果我们深入思考一步，发现这个BlockingQueue队列似乎最开始就默认需要了，但是为什么需要队列，Have you thought about it？这个就要道道线程池的工作原理。</p><h5 id="我们需要了解的Java线程池工作原理"><a href="#我们需要了解的Java线程池工作原理" class="headerlink" title="我们需要了解的Java线程池工作原理"></a>我们需要了解的Java线程池工作原理</h5><p>线程池内的线程数的大小相关的概念有两个，一个是核心池大小（corePoolSize），还有最大线程池大小（maximumPoolSize）。如果当前的线程个数比核心池个数小，当线程任务到来，会优先创建一个新的线程并执行任务。当已经到达核心池大小，则把任务放入队列，为了资源不被耗尽，队列的最大容量可能也是有上限的，如果达到队列上限则考虑继续创建新线程执行任务，如果此刻线程的个数已经到达最大线程池的上限话，则考虑把任务丢弃。</p><p>然后我从网上随便找了张图，放到这方便理解。</p><p><img src="Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%5CThreadPool.png"></p><p>所以这就比较方便理解上面调用ThreadPoolExecutor来自己创建线程池中的一些参数了。当然，ThreadPoolExecutor的构造函数有四种，我选取一个参数最完整的构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                              RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><p>那一起来看一下这些参数的具体意思。</p><p><strong>corePoolSize</strong>：核心池大小，需要注意的是在初创建线程池时线程不会立即启动，直到有任务提交才开始启动线程并逐渐时线程数目达到corePoolSize。若想一开始就创建所有核心线程需调用<code>prestartAllCoreThreads</code>方法。</p><p><strong>maximumPoolSize</strong>：池中允许的最大线程数。需要注意的是当核心线程满且阻塞队列也满时才会判断当前线程数是否小于最大线程数，并决定是否创建新线程。</p><p><strong>keepAliveTime</strong>：当线程数大于核心时，多于的空闲线程最多存活时间。</p><p><strong>unit</strong> ：keepAliveTime 参数的时间单位。</p><p><strong>workQueue</strong> ：当线程数目超过核心线程数时用于保存任务的队列。主要有3种类型的BlockingQueue可供选择：无界队列，有界队列和同步移交。（重要）</p><p><strong>threadFactory</strong> ：执行程序创建新线程时使用的工厂。</p><p><strong>handler</strong> ：阻塞队列已满且线程数达到最大值时所采取的饱和策略。java默认提供了4种饱和策略的实现方式：中止、抛弃、抛弃最旧的、调用者运行。将在下文中详细阐述。（重要）</p><p>我们选取比较复杂和重要的两个参数来介绍一下。（我也是翻阅的资料）</p><h5 id="阻塞队列BlockingQueue"><a href="#阻塞队列BlockingQueue" class="headerlink" title="阻塞队列BlockingQueue"></a>阻塞队列BlockingQueue</h5><p>如果运行的线程少于corePoolSize，则Executor会首先添加新的线程直接去运行，不会进入BlockingQueue排队等候；如果运行的线程大于等于corePoolSize，则Executor就会将新任务请求加入BlockingQueue排队等候。而BlockingQueue主要有三种类型：<code>无界队列</code>，<code>有界队列</code>，<code>同步移交队列</code>。</p><p><strong>无界队列</strong></p><p>队列的大小无限制，就是前面提到过不指定容量默认使用的LinkedBlockingQueue，如果不指定容量大小的话，当任务线程池中耗时较长就会导致大量新任务在队列中堆积导致OOM。</p><p><strong>有界队列</strong></p><p>有界队列也存在两类：遵循FIFO原则的队列（ArrayBlockingQueue，LinkedBlockingQueue）和优先级队列（PriorityBlockingQueue），优先级由任务的Comparator决定。使用有界队列时队列大小需要和线程池大小相配合，线程池较小，有界队列较大时可以减少内存消耗，降低CPU使用率，但是会限制QPS。</p><p><strong>同步移交队列</strong></p><p>如果不希望任务在队列中等待而是希望将任务直接移交给工作线程，可使用<code>SynchronousQueue</code>作为等待队列。SynchronousQueue不是一个真正的队列，而是一种线程之间移交的机制。要将一个元素放入SynchronousQueue中，必须有另一个线程正在等待接收这个元素。只有在使用无界线程池或者有饱和策略时才建议使用该队列。</p><h5 id="饱和策略RejectedExecutionHandler"><a href="#饱和策略RejectedExecutionHandler" class="headerlink" title="饱和策略RejectedExecutionHandler"></a>饱和策略RejectedExecutionHandler</h5><p>JDK提供四种饱和策略，都作为静态内部类在ThreadPoolExcutor中进行实现。</p><p><strong>AbortPolicy终止策略</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * Always throws RejectedExecutionException.</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@throws</span> RejectedExecutionException always</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Task &quot;</span> + r.toString() +</span><br><span class="line">                                              <span class="string">&quot; rejected from &quot;</span> +</span><br><span class="line">                                              e.toString());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通过代码可以看出，该策略是默认饱和策略。使用该策略时在饱和时会抛出RejectedExecutionException（继承自RuntimeException），调用者可捕获该异常自行处理。</p><p><strong>DiscardPolicy抛弃策略</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Does nothing, which has the effect of discarding task r.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不作任何处理，相当于直接抛弃任务。</p><p><strong>DiscardOldestPolicy抛弃旧任务策略</strong></p><p>如代码，先将阻塞队列中的头元素出队抛弃（poll），再尝试提交任务（execute）。如果此时阻塞队列使用PriorityBlockingQueue优先级队列，将会导致优先级最高的任务被抛弃，因此不建议将该种策略配合优先级队列使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Obtains and ignores the next task that the executor</span></span><br><span class="line"><span class="comment">     * would otherwise execute, if one is immediately available,</span></span><br><span class="line"><span class="comment">     * and then retries execution of task r, unless the executor</span></span><br><span class="line"><span class="comment">     * is shut down, in which case task r is instead discarded.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            e.getQueue().poll();</span><br><span class="line">            e.execute(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CallerRunsPolicy调用者运行策略</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes task r in the caller&#x27;s thread, unless the executor</span></span><br><span class="line"><span class="comment">     * has been shut down, in which case the task is discarded.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既不抛弃任务也不抛出异常，直接运行任务的run方法，换言之将任务回退给调用者来直接运行。使用该策略时线程池饱和后将由调用线程池的主线程自己来执行任务，因此在执行任务的这段时间里主线程无法再提交新任务，从而使线程池中工作线程有时间将正在处理的任务处理完成。</p><p>Java线程池就介绍到这里。</p><p>完。</p></div><footer><div class="tags"><a class="tags-none-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></div><div class="clearfix"></div></footer></article></div></div><footer id="footer"><div class="copyright">&copy; 2022 <a href="/">pross</a> <span>,</span> Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a></div><div class="clearfix"></div></footer><script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script><script src="/js/scale.fix.js"></script><script src="/js/jquery.imagesloaded.min.js"></script><script src="/js/gallery.js"></script><link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css"><script src="/fancybox/jquery.fancybox.pack.js"></script><script type="text/javascript">jQuery(".fancybox").fancybox()</script></body></html>